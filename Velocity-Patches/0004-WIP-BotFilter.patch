From b60c1aa5e6fb1d4516fa48512f8c820e139ccc2d Mon Sep 17 00:00:00 2001
From: Leymooo <vjatseslav.maspanov@gmail.com>
Date: Sun, 4 Apr 2021 11:14:53 +0300
Subject: [PATCH] [WIP] BotFilter


diff --git a/HEADER_BOTFILTER.txt b/HEADER_BOTFILTER.txt
new file mode 100644
index 00000000..fdaaab86
--- /dev/null
+++ b/HEADER_BOTFILTER.txt
@@ -0,0 +1,15 @@
+Velocity-BotFilter
+Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU Affero General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Affero General Public License for more details.
+
+You should have received a copy of the GNU Affero General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
\ No newline at end of file
diff --git a/HEADER_MCPROTOCOLLIB.txt b/HEADER_MCPROTOCOLLIB.txt
new file mode 100644
index 00000000..2e0cb6d7
--- /dev/null
+++ b/HEADER_MCPROTOCOLLIB.txt
@@ -0,0 +1,22 @@
+This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+
+Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+Copyright (c) contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/LICENSE_BOTFILTER b/LICENSE_BOTFILTER
new file mode 100644
index 00000000..0ad25db4
--- /dev/null
+++ b/LICENSE_BOTFILTER
@@ -0,0 +1,661 @@
+                    GNU AFFERO GENERAL PUBLIC LICENSE
+                       Version 3, 19 November 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU Affero General Public License is a free, copyleft license for
+software and other kinds of works, specifically designed to ensure
+cooperation with the community in the case of network server software.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+our General Public Licenses are intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  Developers that use our General Public Licenses protect your rights
+with two steps: (1) assert copyright on the software, and (2) offer
+you this License which gives you legal permission to copy, distribute
+and/or modify the software.
+
+  A secondary benefit of defending all users' freedom is that
+improvements made in alternate versions of the program, if they
+receive widespread use, become available for other developers to
+incorporate.  Many developers of free software are heartened and
+encouraged by the resulting cooperation.  However, in the case of
+software used on network servers, this result may fail to come about.
+The GNU General Public License permits making a modified version and
+letting the public access it on a server without ever releasing its
+source code to the public.
+
+  The GNU Affero General Public License is designed specifically to
+ensure that, in such cases, the modified source code becomes available
+to the community.  It requires the operator of a network server to
+provide the source code of the modified version running there to the
+users of that server.  Therefore, public use of a modified version, on
+a publicly accessible server, gives the public access to the source
+code of the modified version.
+
+  An older license, called the Affero General Public License and
+published by Affero, was designed to accomplish similar goals.  This is
+a different license, not a version of the Affero GPL, but Affero has
+released a new version of the Affero GPL which permits relicensing under
+this license.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU Affero General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Remote Network Interaction; Use with the GNU General Public License.
+
+  Notwithstanding any other provision of this License, if you modify the
+Program, your modified version must prominently offer all users
+interacting with it remotely through a computer network (if your version
+supports such interaction) an opportunity to receive the Corresponding
+Source of your version by providing access to the Corresponding Source
+from a network server at no charge, through some standard or customary
+means of facilitating copying of software.  This Corresponding Source
+shall include the Corresponding Source for any work covered by version 3
+of the GNU General Public License that is incorporated pursuant to the
+following paragraph.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the work with which it is combined will remain governed by version
+3 of the GNU General Public License.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU Affero General Public License from time to time.  Such new versions
+will be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU Affero General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU Affero General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU Affero General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License as published
+    by the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Affero General Public License for more details.
+
+    You should have received a copy of the GNU Affero General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If your software can interact with users remotely through a computer
+network, you should also make sure that it provides a way for users to
+get its source.  For example, if your program is a web application, its
+interface could display a "Source" link that leads users to an archive
+of the code.  There are many ways you could offer source, and different
+solutions will be better for different programs; see section 13 for the
+specific requirements.
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU AGPL, see
+<https://www.gnu.org/licenses/>.
diff --git a/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java b/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java
index 0bbdc45b..6c88c603 100644
--- a/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java
+++ b/api/src/main/java/com/velocitypowered/api/network/ProtocolVersion.java
@@ -230,6 +230,28 @@ public enum ProtocolVersion {
     return this == LEGACY;
   }
 
+  //BotFilter start
+  public boolean isBefore(ProtocolVersion other) {
+    return this.compareTo(other) < 0;
+  }
+
+  public boolean isBeforeOrEq(ProtocolVersion other) {
+    return this.compareTo(other) <= 0;
+  }
+
+  public boolean isAfter(ProtocolVersion other) {
+    return this.compareTo(other) > 0;
+  }
+
+  public boolean isAfterOrEq(ProtocolVersion other) {
+    return this.compareTo(other) >= 0;
+  }
+  //BotFilter add
+
+  public static ProtocolVersion adapt(int protocol) {
+    return ID_TO_PROTOCOL_CONSTANT.get(protocol);
+  }
+
   @Override
   public String toString() {
     return getVersionIntroducedIn();
diff --git a/native/src/main/java/com/velocitypowered/natives/compression/Java11VelocityCompressor.java b/native/src/main/java/com/velocitypowered/natives/compression/Java11VelocityCompressor.java
index be3ed64e..cc450b1a 100644
--- a/native/src/main/java/com/velocitypowered/natives/compression/Java11VelocityCompressor.java
+++ b/native/src/main/java/com/velocitypowered/natives/compression/Java11VelocityCompressor.java
@@ -66,6 +66,7 @@ public class Java11VelocityCompressor implements VelocityCompressor {
   private boolean disposed = false;
 
   private Java11VelocityCompressor(int level) {
+    level = Math.min(9, level); //BotFilter
     this.deflater = new Deflater(level);
     this.inflater = new Inflater();
   }
diff --git a/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java b/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java
index 97127d25..96084c96 100644
--- a/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java
+++ b/native/src/main/java/com/velocitypowered/natives/compression/JavaVelocityCompressor.java
@@ -37,6 +37,7 @@ public class JavaVelocityCompressor implements VelocityCompressor {
   private boolean disposed = false;
 
   private JavaVelocityCompressor(int level) {
+    level = Math.min(9, level); //BotFilter
     this.deflater = new Deflater(level);
     this.inflater = new Inflater();
   }
diff --git a/proxy/build.gradle b/proxy/build.gradle
index e4e91469..837daf0d 100644
--- a/proxy/build.gradle
+++ b/proxy/build.gradle
@@ -2,14 +2,20 @@ import com.github.jengelman.gradle.plugins.shadow.transformers.Log4j2PluginsCach
 
 plugins {
     id 'java'
-    id 'checkstyle'
+    //id 'checkstyle'
 }
 
 apply plugin: 'org.cadixdev.licenser'
-apply from: '../gradle/checkstyle.gradle'
+//apply from: '../gradle/checkstyle.gradle'
 apply plugin: 'com.github.johnrengelman.shadow'
 
 license {
+    matching(includes: ['**/botfilter/**']) {
+        header = project.rootProject.file('HEADER_BOTFILTER.txt')
+    }
+    matching(includes: ['**/mcprotocollib/**']) {
+        header = project.rootProject.file('HEADER_MCPROTOCOLLIB.txt')
+    }
     header = project.rootProject.file('HEADER.txt')
 }
 
@@ -43,12 +49,19 @@ jar {
 shadowJar {
     transform(Log4j2PluginsCacheFileTransformer)
 }
+//tasks.withType(Checkstyle) {
+//    exclude('**/com/velocitypowered/proxy/protocol/packet/*.java')
+//}
 
-tasks.withType(Checkstyle) {
-    exclude('**/com/velocitypowered/proxy/protocol/packet/*.java')
-}
 
 dependencies {
+    //BotFilter add lombok
+    compileOnly 'org.projectlombok:lombok:1.18.20'
+    annotationProcessor 'org.projectlombok:lombok:1.18.20'
+
+    testCompileOnly 'org.projectlombok:lombok:1.18.20'
+    testAnnotationProcessor 'org.projectlombok:lombok:1.18.20'
+
     // Note: we depend on the API twice, first the main sourceset, and then the annotation processor.
     implementation project(':velocity-api')
     implementation project(':velocity-api').sourceSets.ap.output
@@ -92,13 +105,6 @@ dependencies {
     testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
     testImplementation "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
 
-    //BotFilter add lombok
-    compileOnly 'org.projectlombok:lombok:1.18.20'
-    annotationProcessor 'org.projectlombok:lombok:1.18.20'
-
-    testCompileOnly 'org.projectlombok:lombok:1.18.20'
-    testAnnotationProcessor 'org.projectlombok:lombok:1.18.20'
-
     implementation 'ru.leymooo:AnnotatedYAMLConfiguration-standalone:1.1-SNAPSHOT' //BotFilter
 }
 
diff --git a/proxy/lombok.config b/proxy/lombok.config
new file mode 100644
index 00000000..a284c48a
--- /dev/null
+++ b/proxy/lombok.config
@@ -0,0 +1,3 @@
+# This file is generated by the 'io.freefair.lombok' Gradle plugin
+config.stopBubbling = true
+lombok.extern.findbugs.addSuppressFBWarnings = true
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
index 0d005726..7615651d 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
@@ -103,6 +103,7 @@ import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import ru.leymooo.botfilter.BotFilter;
 
 public class VelocityServer implements ProxyServer, ForwardingAudience {
 
@@ -142,6 +143,7 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
   private final VelocityEventManager eventManager;
   private final VelocityScheduler scheduler;
   private final VelocityChannelRegistrar channelRegistrar = new VelocityChannelRegistrar();
+  private @MonotonicNonNull BotFilter botFilter; //BotFilter
 
   VelocityServer(final ProxyOptions options) {
     pluginManager = new VelocityPluginManager(this);
@@ -219,6 +221,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
 
     this.doStartupConfigLoad();
 
+    this.botFilter = new BotFilter(this); //BotFilter init
+
     for (Map.Entry<String, String> entry : configuration.getServers().entrySet()) {
       servers.register(new ServerInfo(entry.getKey(), AddressUtil.parseAddress(entry.getValue())));
     }
@@ -682,6 +686,11 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     return bossBarManager;
   }
 
+  //BotFilter - add getter
+  public BotFilter getBotFilter() {
+    return botFilter;
+  }
+
   public static Gson getPingGsonInstance(ProtocolVersion version) {
     return version.compareTo(ProtocolVersion.MINECRAFT_1_16) >= 0 ? POST_1_16_PING_SERIALIZER
         : PRE_1_16_PING_SERIALIZER;
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java
index ba172db4..1e41286f 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftConnection.java
@@ -247,7 +247,8 @@ public class MinecraftConnection extends ChannelInboundHandlerAdapter {
     if (channel.isActive()) {
       boolean is17 = this.getProtocolVersion().compareTo(ProtocolVersion.MINECRAFT_1_8) < 0
           && this.getProtocolVersion().compareTo(ProtocolVersion.MINECRAFT_1_7_2) >= 0;
-      if (is17 && this.getState() != StateRegistry.STATUS) {
+      //BotFilter looks like it works ok for Login protocol
+      if (is17 && this.getState() == StateRegistry.PLAY) {
         channel.eventLoop().execute(() -> {
           // 1.7.x versions have a race condition with switching protocol states, so just explicitly
           // close the connection after a short while.
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java
index e72f42d6..e950991f 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/MinecraftSessionHandler.java
@@ -53,6 +53,7 @@ import com.velocitypowered.proxy.protocol.packet.title.TitleSubtitlePacket;
 import com.velocitypowered.proxy.protocol.packet.title.TitleTextPacket;
 import com.velocitypowered.proxy.protocol.packet.title.TitleTimesPacket;
 import io.netty.buffer.ByteBuf;
+import ru.leymooo.botfilter.protocol.packet.PlayerPositionAndLook;
 
 public interface MinecraftSessionHandler {
 
@@ -231,4 +232,10 @@ public interface MinecraftSessionHandler {
   default boolean handle(ResourcePackResponse packet) {
     return false;
   }
+
+  //BotFilter start - add handle methods
+  default boolean handle(PlayerPositionAndLook packet) {
+    return false;
+  }
+  //BotFilter end
 }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java
index c1967e85..6d12ef71 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/connection/client/LoginSessionHandler.java
@@ -51,6 +51,7 @@ import com.velocitypowered.proxy.protocol.packet.ServerLogin;
 import com.velocitypowered.proxy.protocol.packet.ServerLoginSuccess;
 import com.velocitypowered.proxy.protocol.packet.SetCompression;
 import io.netty.buffer.ByteBuf;
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
@@ -227,10 +228,10 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
         onlineMode);
     final GameProfile finalProfile = profile;
 
-    server.getEventManager().fire(profileRequestEvent).thenComposeAsync(profileEvent -> {
+    server.getEventManager().fire(profileRequestEvent).thenAcceptAsync(profileEvent -> {
       if (mcConnection.isClosed()) {
-        // The player disconnected after we authenticated them.
-        return CompletableFuture.completedFuture(null);
+        // The player disconnected while event execution
+        return;
       }
 
       // Initiate a regular connection and move over to it.
@@ -239,40 +240,32 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
       this.connectedPlayer = player;
       if (!server.canRegisterConnection(player)) {
         player.disconnect0(server.getConfiguration().getMessages().getAlreadyConnected(), true);
-        return CompletableFuture.completedFuture(null);
+        return;
       }
 
       logger.info("{} has connected", player);
+      injectBotFilterOrFinishLogin(player);
 
-      return server.getEventManager()
-          .fire(new PermissionsSetupEvent(player, ConnectedPlayer.DEFAULT_PERMISSIONS))
-          .thenAcceptAsync(event -> {
-            if (!mcConnection.isClosed()) {
-              // wait for permissions to load, then set the players permission function
-              final PermissionFunction function = event.createFunction(player);
-              if (function == null) {
-                logger.error(
-                    "A plugin permission provider {} provided an invalid permission function"
-                        + " for player {}. This is a bug in the plugin, not in Velocity. Falling"
-                        + " back to the default permission function.",
-                    event.getProvider().getClass().getName(),
-                    player.getUsername());
-              } else {
-                player.setPermissionFunction(function);
-              }
-              completeLoginProtocolPhaseAndInitialize(player);
-            }
-          }, mcConnection.eventLoop());
     }, mcConnection.eventLoop()).exceptionally((ex) -> {
       logger.error("Exception during connection of {}", finalProfile, ex);
       return null;
-    });  
+    });
   }
 
-  private void completeLoginProtocolPhaseAndInitialize(ConnectedPlayer player) {
+  private void injectBotFilterOrFinishLogin(ConnectedPlayer player) {
+
+    if (server.getBotFilter().shouldCheck(player)) {
+      server.getBotFilter().setupPipelineAndStartCheck(player, this);
+    } else {
+      completeLoginProtocol(player, true);
+      initialize(player);
+    }
+  }
+
+  public void completeLoginProtocol(ConnectedPlayer player, boolean flush) {
     int threshold = server.getConfiguration().getCompressionThreshold();
     if (threshold >= 0 && mcConnection.getProtocolVersion().compareTo(MINECRAFT_1_8) >= 0) {
-      mcConnection.write(new SetCompression(threshold));
+      mcConnection.delayedWrite(new SetCompression(threshold));
       mcConnection.setCompressionThreshold(threshold);
     }
     VelocityConfiguration configuration = server.getConfiguration();
@@ -283,38 +276,62 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
     ServerLoginSuccess success = new ServerLoginSuccess();
     success.setUsername(player.getUsername());
     success.setUuid(playerUniqueId);
-    mcConnection.write(success);
+    mcConnection.delayedWrite(success);
+    if (flush) {
+      mcConnection.flush();
+    }
+  }
 
+
+  public void initialize(ConnectedPlayer player) {
     mcConnection.setAssociation(player);
     mcConnection.setState(StateRegistry.PLAY);
-
-    server.getEventManager().fire(new LoginEvent(player))
-        .thenAcceptAsync(event -> {
+    server.getEventManager()
+        .fire(new PermissionsSetupEvent(player, ConnectedPlayer.DEFAULT_PERMISSIONS))
+        .thenComposeAsync(premissionEvent -> {
           if (mcConnection.isClosed()) {
-            // The player was disconnected
-            server.getEventManager().fireAndForget(new DisconnectEvent(player,
-                LoginStatus.CANCELLED_BY_USER_BEFORE_COMPLETE));
-            return;
+            return CompletableFuture.completedFuture(null);
           }
-
-          Optional<Component> reason = event.getResult().getReasonComponent();
-          if (reason.isPresent()) {
-            player.disconnect0(reason.get(), true);
+          // wait for permissions to load, then set the players permission function
+          final PermissionFunction function = premissionEvent.createFunction(player);
+          if (function == null) {
+            logger.error(
+                "A plugin permission provider {} provided an invalid permission function"
+                    + " for player {}. This is a bug in the plugin, not in Velocity. Falling"
+                    + " back to the default permission function.",
+                premissionEvent.getProvider().getClass().getName(),
+                player.getUsername());
           } else {
-            if (!server.registerConnection(player)) {
-              player.disconnect0(server.getConfiguration().getMessages()
-                      .getAlreadyConnected(), true);
-              return;
-            }
-
-            mcConnection.setSessionHandler(new InitialConnectSessionHandler(player));
-            server.getEventManager().fire(new PostLoginEvent(player))
-                .thenCompose((ignored) -> connectToInitialServer(player))
-                .exceptionally((ex) -> {
-                  logger.error("Exception while connecting {} to initial server", player, ex);
-                  return null;
-                });
+            player.setPermissionFunction(function);
           }
+          return server.getEventManager().fire(new LoginEvent(player))
+              .thenAcceptAsync(event -> {
+                if (mcConnection.isClosed()) {
+                  // The player was disconnected
+                  server.getEventManager().fireAndForget(new DisconnectEvent(player,
+                      LoginStatus.CANCELLED_BY_USER_BEFORE_COMPLETE));
+                  return;
+                }
+
+                Optional<Component> reason = event.getResult().getReasonComponent();
+                if (reason.isPresent()) {
+                  player.disconnect0(reason.get(), true);
+                } else {
+                  if (!server.registerConnection(player)) {
+                    player.disconnect0(server.getConfiguration().getMessages()
+                        .getAlreadyConnected(), true);
+                    return;
+                  }
+
+                  mcConnection.setSessionHandler(new InitialConnectSessionHandler(player));
+                  server.getEventManager().fire(new PostLoginEvent(player))
+                      .thenCompose((ignored) -> connectToInitialServer(player))
+                      .exceptionally((ex) -> {
+                        logger.error("Exception while connecting {} to initial server", player, ex);
+                        return null;
+                      });
+                }
+              }, mcConnection.eventLoop());
         }, mcConnection.eventLoop())
         .exceptionally((ex) -> {
           logger.error("Exception while completing login initialisation phase for {}", player, ex);
@@ -332,7 +349,7 @@ public class LoginSessionHandler implements MinecraftSessionHandler {
           Optional<RegisteredServer> toTry = event.getInitialServer();
           if (!toTry.isPresent()) {
             player.disconnect0(server.getConfiguration().getMessages()
-                    .getNoAvailableServers(), true);
+                .getNoAvailableServers(), true);
             return;
           }
           player.createConnectionRequest(toTry.get()).fireAndForget();
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java
index 7115bb8b..7b2184d9 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/MinecraftPacket.java
@@ -19,15 +19,24 @@ package com.velocitypowered.proxy.protocol;
 
 import com.velocitypowered.api.network.ProtocolVersion;
 import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
 import io.netty.buffer.ByteBuf;
 
 public interface MinecraftPacket {
 
-  void decode(ByteBuf buf, ProtocolUtils.Direction direction, ProtocolVersion protocolVersion);
+  //BotFilter start - add default to methods
+  default void decode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException();
+  }
 
-  void encode(ByteBuf buf, ProtocolUtils.Direction direction, ProtocolVersion protocolVersion);
+  default void encode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException();
+  }
 
-  boolean handle(MinecraftSessionHandler handler);
+  default boolean handle(MinecraftSessionHandler handler) {
+    throw new UnsupportedOperationException();
+  }
+  //BotFilter end
 
   default int expectedMaxLength(ByteBuf buf, ProtocolUtils.Direction direction,
       ProtocolVersion version) {
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java
index 8e787539..49b1001d 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/StateRegistry.java
@@ -79,6 +79,7 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.function.Supplier;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import ru.leymooo.botfilter.protocol.BotFilterProtocol;
 
 public enum StateRegistry {
 
@@ -296,7 +297,7 @@ public enum StateRegistry {
       clientbound.register(LoginPluginMessage.class, LoginPluginMessage::new,
           map(0x04, MINECRAFT_1_13, false));
     }
-  };
+  }, BotFilter{}; //BotFilter custom state registry
 
   public static final int STATUS_ID = 1;
   public static final int LOGIN_ID = 2;
@@ -322,7 +323,8 @@ public enum StateRegistry {
       this.versions = Collections.unmodifiableMap(mutableVersions);
     }
 
-    ProtocolRegistry getProtocolRegistry(final ProtocolVersion version) {
+    //BotFilter public
+    public ProtocolRegistry getProtocolRegistry(final ProtocolVersion version) {
       ProtocolRegistry registry = versions.get(version);
       if (registry == null) {
         if (fallback) {
@@ -333,7 +335,8 @@ public enum StateRegistry {
       return registry;
     }
 
-    <P extends MinecraftPacket> void register(Class<P> clazz, Supplier<P> packetSupplier,
+    //BotFilter public
+    public <P extends MinecraftPacket> void register(Class<P> clazz, Supplier<P> packetSupplier,
         PacketMapping... mappings) {
       if (mappings.length == 0) {
         throw new IllegalArgumentException("At least one mapping must be provided.");
@@ -419,7 +422,7 @@ public enum StateRegistry {
       }
 
       /**
-       * Attempts to look up the packet ID for an {@code packet}.
+       * Attempts to look up the packet ID for a {@code packet}.
        *
        * @param packet the packet to look up
        * @return the packet ID
@@ -435,6 +438,23 @@ public enum StateRegistry {
         }
         return id;
       }
+      /**
+       * Attempts to look up the packet ID for a {@code packet} class.
+       *
+       * @param clazz the packet class to look up
+       * @return the packet ID
+       * @throws IllegalArgumentException if the packet ID is not found
+       */
+      public int getPacketId(final Class<? extends MinecraftPacket> clazz) {
+        final int id = this.packetClassToId.getInt(clazz);
+        if (id == Integer.MIN_VALUE) {
+          throw new IllegalArgumentException(String.format(
+              "Unable to find id for packet of type %s in %s protocol %s",
+              clazz.getName(), PacketRegistry.this.direction, this.version
+          ));
+        }
+        return id;
+      }
     }
   }
 
@@ -490,7 +510,8 @@ public enum StateRegistry {
    * @param encodeOnly When true packet decoding will be disabled
    * @return PacketMapping with the provided arguments
    */
-  private static PacketMapping map(int id, ProtocolVersion version, boolean encodeOnly) {
+  //BotFilter public
+  public static PacketMapping map(int id, ProtocolVersion version, boolean encodeOnly) {
     return map(id, version, null, encodeOnly);
   }
 
@@ -503,7 +524,8 @@ public enum StateRegistry {
    * @param lastValidProtocolVersion Last version this Mapping is valid at
    * @return PacketMapping with the provided arguments
    */
-  private static PacketMapping map(int id, ProtocolVersion version,
+  //BotFilter public
+  public static PacketMapping map(int id, ProtocolVersion version,
           ProtocolVersion lastValidProtocolVersion, boolean encodeOnly) {
     return new PacketMapping(id, version, lastValidProtocolVersion, encodeOnly);
   }
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCipherEncoder.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCipherEncoder.java
index b4fd027e..c513da9d 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCipherEncoder.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCipherEncoder.java
@@ -35,6 +35,7 @@ public class MinecraftCipherEncoder extends MessageToMessageEncoder<ByteBuf> {
 
   @Override
   protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {
+    System.out.println("Processing cipher");
     ByteBuf compatible = MoreByteBufUtils.ensureCompatible(ctx.alloc(), cipher, msg);
     try {
       cipher.process(compatible);
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCompressorAndLengthEncoder.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCompressorAndLengthEncoder.java
index 28d00516..2c9df7e3 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCompressorAndLengthEncoder.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftCompressorAndLengthEncoder.java
@@ -42,6 +42,7 @@ public class MinecraftCompressorAndLengthEncoder extends MessageToByteEncoder<By
 
   @Override
   protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {
+    System.out.println("processing compression & varint");
     int uncompressed = msg.readableBytes();
     if (uncompressed < threshold) {
       // Under the threshold, there is nothing to do.
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftVarintLengthEncoder.java b/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftVarintLengthEncoder.java
index f65764bf..264957c2 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftVarintLengthEncoder.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/protocol/netty/MinecraftVarintLengthEncoder.java
@@ -36,6 +36,7 @@ public class MinecraftVarintLengthEncoder extends MessageToByteEncoder<ByteBuf>
 
   @Override
   protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {
+    System.out.println("processing varint");
     ProtocolUtils.writeVarInt(out, msg.readableBytes());
     out.writeBytes(msg);
   }
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/BotFilter.java b/proxy/src/main/java/ru/leymooo/botfilter/BotFilter.java
new file mode 100644
index 00000000..fe7130ab
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/BotFilter.java
@@ -0,0 +1,88 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter;
+
+import com.velocitypowered.proxy.VelocityServer;
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
+import com.velocitypowered.proxy.connection.client.LoginSessionHandler;
+import com.velocitypowered.proxy.network.Connections;
+import io.netty.channel.ChannelPipeline;
+import lombok.Getter;
+import lombok.ToString;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import ru.leymooo.botfilter.config.BotFilterConfiguration;
+import ru.leymooo.botfilter.protocol.cache.netty.MultiplePreparedPacketsEncoder;
+import ru.leymooo.botfilter.protocol.cache.netty.PreparedPacketEncoder;
+import ru.leymooo.botfilter.server.BotFilterSessionHandler;
+import ru.leymooo.botfilter.server.VirtualServer;
+
+@Getter
+@ToString
+public class BotFilter {
+
+  private static final Logger LOGGER = LogManager.getLogger("BotFilter");
+
+  private final VelocityServer velocityServer;
+  private final BotFilterConfiguration botFilterConfiguration;
+  private final VirtualServer virtualServer;
+
+
+  public BotFilter(VelocityServer velocityServer) {
+    LOGGER.info("BotFilter 1.0");
+    this.velocityServer = velocityServer;
+    this.botFilterConfiguration = BotFilterConfiguration.create();
+    this.virtualServer = new VirtualServer(this);
+    this.virtualServer.reload();
+  }
+
+  public boolean shouldCheck(ConnectedPlayer player) {
+    return true;
+  }
+
+  public void setupPipelineAndStartCheck(ConnectedPlayer player, LoginSessionHandler handler) {
+    try {
+      BotFilterSessionHandler sessionHandler = new BotFilterSessionHandler(player, handler,
+          virtualServer);
+      LOGGER.info(sessionHandler.getPlayer().getUsername());
+
+      MinecraftConnection connection = sessionHandler.getPlayer().getConnection();
+      connection.setSessionHandler(sessionHandler);
+
+      ChannelPipeline pipeline = connection.getChannel().pipeline();
+      System.out.println("pre changed");
+      if (sessionHandler.getPlayer().isOnlineMode()) {
+        pipeline.addAfter(Connections.CIPHER_ENCODER, "prepared-encoder",
+            PreparedPacketEncoder.getEncoder(connection.getProtocolVersion(), true));
+      } else {
+        pipeline.addFirst("prepared-encoder",
+            PreparedPacketEncoder.getEncoder(connection.getProtocolVersion(), false));
+        pipeline.addFirst("multipleprepared-encoder",
+            MultiplePreparedPacketsEncoder.getEncoder(connection.getProtocolVersion()));
+      }
+      System.out.println("changed");
+
+      virtualServer.spawnPlayer(sessionHandler);
+    } catch (Throwable t) {
+      LOGGER.error("Error", t);
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/config/BotFilterConfiguration.java b/proxy/src/main/java/ru/leymooo/botfilter/config/BotFilterConfiguration.java
new file mode 100644
index 00000000..ed81f310
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/config/BotFilterConfiguration.java
@@ -0,0 +1,46 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.config;
+
+import java.io.File;
+import lombok.Getter;
+import lombok.ToString;
+import ru.leymooo.annotatedyaml.Annotations.Final;
+import ru.leymooo.annotatedyaml.Annotations.Key;
+import ru.leymooo.annotatedyaml.Configuration;
+import ru.leymooo.annotatedyaml.provider.StandaloneConfigurationProvider;
+
+@Getter
+@ToString
+public class BotFilterConfiguration extends Configuration {
+
+
+  @Final
+  @Key("config-version")
+  private final String configVersion = "1.0";
+
+
+  public static BotFilterConfiguration create() {
+    BotFilterConfiguration configuration = Configuration.builder(BotFilterConfiguration.class)
+        .file(new File("BotFilter", "config.yml"))
+        .provider(StandaloneConfigurationProvider.class)
+        .build();
+    return configuration;
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/BotFilterProtocol.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/BotFilterProtocol.java
new file mode 100644
index 00000000..2cb801f0
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/BotFilterProtocol.java
@@ -0,0 +1,91 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol;
+
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_13;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_14;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_15;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_16;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_16_2;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_17;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_7_2;
+import static com.velocitypowered.api.network.ProtocolVersion.MINECRAFT_1_9;
+import static com.velocitypowered.proxy.protocol.StateRegistry.map;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import ru.leymooo.botfilter.protocol.packet.JoinGame;
+import ru.leymooo.botfilter.protocol.packet.PlayerPositionAndLook;
+import ru.leymooo.botfilter.protocol.packet.UpdateViewPosition;
+import ru.leymooo.botfilter.protocol.packet.world.ChunkData;
+import ru.leymooo.botfilter.protocol.packet.world.UpdateLight;
+
+public class BotFilterProtocol {
+
+  public static void init() {
+    StateRegistry.BotFilter.clientbound.register(
+        JoinGame.class, JoinGame::new,
+        map(0x01, MINECRAFT_1_7_2, false),
+        map(0x23, MINECRAFT_1_9, false),
+        map(0x25, MINECRAFT_1_13, false),
+        map(0x25, MINECRAFT_1_14, false),
+        map(0x26, MINECRAFT_1_15, false),
+        map(0x25, MINECRAFT_1_16, false),
+        map(0x24, MINECRAFT_1_16_2, false),
+        map(0x26, MINECRAFT_1_17, false)
+    );
+    StateRegistry.BotFilter.clientbound.register(
+        PlayerPositionAndLook.class, PlayerPositionAndLook::new,
+        map(0x08, ProtocolVersion.MINECRAFT_1_7_2, true),
+        map(0x2E, ProtocolVersion.MINECRAFT_1_9, true),
+        map(0x2F, ProtocolVersion.MINECRAFT_1_12_1, true),
+        map(0x32, ProtocolVersion.MINECRAFT_1_13, true),
+        map(0x35, ProtocolVersion.MINECRAFT_1_14, true),
+        map(0x36, ProtocolVersion.MINECRAFT_1_15, true),
+        map(0x35, ProtocolVersion.MINECRAFT_1_16, true),
+        map(0x34, ProtocolVersion.MINECRAFT_1_16_2, true),
+        map(0x38, ProtocolVersion.MINECRAFT_1_17, true));
+
+    StateRegistry.BotFilter.clientbound.register(
+        ChunkData.class, ChunkData::new,
+        map(0x21, ProtocolVersion.MINECRAFT_1_7_2, true),
+        map(0x21, ProtocolVersion.MINECRAFT_1_8, true),
+        map(0x20, ProtocolVersion.MINECRAFT_1_9, true),
+        map(0x22, ProtocolVersion.MINECRAFT_1_13, true),
+        map(0x21, ProtocolVersion.MINECRAFT_1_14, true),
+        map(0x22, ProtocolVersion.MINECRAFT_1_15, true),
+        map(0x21, ProtocolVersion.MINECRAFT_1_16, true),
+        map(0x20, ProtocolVersion.MINECRAFT_1_16_2, true),
+        map(0x22, ProtocolVersion.MINECRAFT_1_17, true));
+
+    StateRegistry.BotFilter.clientbound.register(
+        UpdateLight.class, UpdateLight::new,
+        map(0x24, ProtocolVersion.MINECRAFT_1_14, true),
+        map(0x25, ProtocolVersion.MINECRAFT_1_15, true),
+        map(0x24, ProtocolVersion.MINECRAFT_1_16, true),
+        map(0x23, ProtocolVersion.MINECRAFT_1_16_2, true),
+        map(0x25, ProtocolVersion.MINECRAFT_1_17, true));
+
+    StateRegistry.BotFilter.clientbound.register(
+        UpdateViewPosition.class, UpdateViewPosition::new,
+        map(0x49, ProtocolVersion.MINECRAFT_1_17, true));
+
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/ByteBufCreator.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/ByteBufCreator.java
new file mode 100644
index 00000000..ab71265c
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/ByteBufCreator.java
@@ -0,0 +1,52 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.cache;
+
+import com.velocitypowered.natives.compression.VelocityCompressor;
+import com.velocitypowered.natives.util.BufferPreference;
+import com.velocitypowered.natives.util.Natives;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+public class ByteBufCreator {
+
+  private static boolean directBuffers = false;
+
+  static {
+    VelocityCompressor compressor = Natives.compress.get().create(1);
+    if (compressor.preferredBufferType() == BufferPreference.DIRECT_PREFERRED
+        || compressor.preferredBufferType() == BufferPreference.DIRECT_REQUIRED) {
+      directBuffers = true;
+    }
+    compressor.close();
+  }
+
+
+  public static ByteBuf newBuffer() {
+    return directBuffers ? Unpooled.directBuffer() : Unpooled.buffer();
+  }
+
+  public static ByteBuf newBuffer(int length) {
+    return directBuffers ? Unpooled.directBuffer(length) : Unpooled.buffer(length);
+  }
+
+  public static boolean isDirectBufferPreferred() {
+    return directBuffers;
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/MultiplePreparedPackets.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/MultiplePreparedPackets.java
new file mode 100644
index 00000000..2f17a6da
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/MultiplePreparedPackets.java
@@ -0,0 +1,99 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.cache;
+
+import com.google.common.base.Preconditions;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import io.netty.buffer.ByteBuf;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Map;
+
+public class MultiplePreparedPackets {
+
+  private Map<ProtocolVersion, ByteBuf> multiplePayloadBuf = new EnumMap<ProtocolVersion, ByteBuf>(
+      ProtocolVersion.class);
+  private PreparedPacket[] onlineModePackets;
+
+  public MultiplePreparedPackets(PreparedPacket... preparedPackets) {
+    for (PreparedPacket packet : preparedPackets) {
+      Preconditions.checkState(packet.isFinished(), "PreparedPacket is not adapted");
+    }
+    onlineModePackets = preparedPackets;
+    createOfflineModePayload(preparedPackets);
+  }
+
+  private void createOfflineModePayload(PreparedPacket... preparedPackets) {
+    for (ProtocolVersion protocolVersion : EnumSet
+        .range(ProtocolVersion.MINIMUM_VERSION, ProtocolVersion.MAXIMUM_VERSION)) {
+      ByteBuf multiple = ByteBufCreator.newBuffer();
+      for (PreparedPacket preparedPacket : preparedPackets) {
+        ByteBuf buf = preparedPacket.getBuffer(protocolVersion);
+        if (buf == null) {
+          continue;
+        }
+        multiple.writeBytes(buf);
+        buf.release();
+      }
+
+      if (multiple.readableBytes() == 0) {
+        multiple.release();
+        continue;
+      }
+      //Deduplicate
+      for (ByteBuf byteBuf : multiplePayloadBuf.values()) {
+        if (byteBuf.equals(multiple)) {
+          multiple.release();
+          multiple = byteBuf;
+          break;
+        }
+      }
+      multiplePayloadBuf.put(protocolVersion, multiple);
+    }
+  }
+
+  public void write(MinecraftConnection connection, boolean onlineMode) {
+    if (onlineMode) {
+      for (PreparedPacket preparedPacket : onlineModePackets) {
+        preparedPacket.selfWrite(connection, false);
+      }
+    } else {
+      connection.delayedWrite(this);
+    }
+  }
+
+  public ByteBuf getBuffer(ProtocolVersion protocolVersion) {
+    return multiplePayloadBuf.get(protocolVersion).retainedSlice();
+  }
+
+  public int getBuffetLength(ProtocolVersion protocolVersion) {
+    return multiplePayloadBuf.get(protocolVersion).readableBytes();
+  }
+
+  public void release() {
+    for (PreparedPacket preparedPacket : onlineModePackets) {
+      preparedPacket.releaseBuffers();
+    }
+    for (ByteBuf byteBuf : new HashSet<>(multiplePayloadBuf.values())) {
+      byteBuf.release();
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/PacketCompressor.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/PacketCompressor.java
new file mode 100644
index 00000000..d1fd4e88
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/PacketCompressor.java
@@ -0,0 +1,69 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.cache;
+
+import com.velocitypowered.natives.compression.VelocityCompressor;
+import com.velocitypowered.natives.util.Natives;
+import com.velocitypowered.proxy.config.VelocityConfiguration;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.util.function.Supplier;
+
+public class PacketCompressor {
+
+  private final ThreadLocal<VelocityCompressor> compressors = ThreadLocal
+      .withInitial(() -> Natives.compress.get().create(12));
+  private final Supplier<VelocityConfiguration> velocityConfiguration;
+
+  /**
+   * Constructs VelocityPacketCompressor.
+   *
+   * @param velocityConfiguration configuration
+   */
+  public PacketCompressor(Supplier<VelocityConfiguration> velocityConfiguration) {
+    this.velocityConfiguration = velocityConfiguration;
+
+  }
+
+  public boolean isCompressionEnabled() {
+    return velocityConfiguration.get().getCompressionThreshold() >= 0;
+  }
+
+  public boolean shouldCompress(int i) {
+    return isCompressionEnabled() && i >= velocityConfiguration.get().getCompressionThreshold();
+  }
+
+  public ByteBuf compress(ByteBuf source) {
+    VelocityCompressor compressor = compressors.get();
+    ByteBuf destination =
+        ByteBufCreator.isDirectBufferPreferred() ? Unpooled.directBuffer() : Unpooled.buffer();
+    int uncompressed = source.readableBytes();
+    ProtocolUtils.writeVarInt(destination, uncompressed);
+    try {
+      compressor.deflate(source, destination);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    } finally {
+      source.release();
+    }
+    return destination;
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/PreparedPacket.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/PreparedPacket.java
new file mode 100644
index 00000000..2f4ae132
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/PreparedPacket.java
@@ -0,0 +1,221 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.cache;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import io.netty.buffer.ByteBuf;
+import io.netty.util.ReferenceCountUtil;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import ru.leymooo.botfilter.protocol.BotFilterProtocol;
+
+
+public class PreparedPacket<T extends MinecraftPacket> {
+
+  static {
+    BotFilterProtocol.init();
+  }
+
+  private final Map<ProtocolVersion, ByteBufHolder> packets =
+      new EnumMap<>(ProtocolVersion.class);
+  private boolean finished = false;
+
+  public PreparedPacket() {
+  }
+
+  public void prepareSinge(T packet, ProtocolVersion version) {
+    prepare(packet, version, version);
+  }
+
+  public void prepareSinge(T packet, ProtocolVersion version, StateRegistry protocol) {
+    prepare(packet, version, version, protocol);
+  }
+
+  public void prepare(T packet) {
+    prepare(packet, ProtocolVersion.MINIMUM_VERSION, ProtocolVersion.MAXIMUM_VERSION);
+  }
+
+  public void prepare(T packet, ProtocolVersion from) {
+    prepare(packet, from, ProtocolVersion.MAXIMUM_VERSION);
+  }
+
+  public void prepare(T packet, ProtocolVersion from, StateRegistry protocol) {
+    prepare(packet, from, ProtocolVersion.MAXIMUM_VERSION, protocol);
+  }
+
+  public void prepare(T packet, ProtocolVersion from, ProtocolVersion to) {
+    prepare(packet, from, to, StateRegistry.BotFilter);
+  }
+
+  public void prepare(T packet, ProtocolVersion from, ProtocolVersion to, StateRegistry protocol) {
+    for (ProtocolVersion protocolVersion : EnumSet.range(from, to)) {
+      ByteBuf buf = encodePacket(packet, protocolVersion, protocol);
+      ByteBufHolder holder = getHolder(buf, protocolVersion);
+      packets.put(protocolVersion, holder);
+    }
+  }
+
+  /*
+  public void preparePacketAndCopy(T packet, ProtocolVersion start, ProtocolVersion end,
+      StateRegistry protocol) {
+    ByteBuf buf = encodePacket(packet, start, protocol);
+    ByteBufHolder holder = new ByteBufHolder(start.isBefore(ProtocolVersion.MINECRAFT_1_8), buf);
+    for (ProtocolVersion protocolVersion : EnumSet.range(start, end)) {
+      prepared.put(protocolVersion, holder);
+    }
+  }
+
+   */
+
+  private ByteBuf encodePacket(T packet, ProtocolVersion version, StateRegistry protocol) {
+    int id = getPacketId(packet, version, protocol);
+    ByteBuf byteBuf = ByteBufCreator.newBuffer();
+    ProtocolUtils.writeVarInt(byteBuf, id);
+    packet.encode(byteBuf, Direction.CLIENTBOUND, version);
+    return byteBuf;
+  }
+
+  private int getPacketId(T packet, ProtocolVersion version, StateRegistry protocol) {
+    try {
+      return protocol.clientbound.getProtocolRegistry(version).getPacketId(packet.getClass());
+    } catch (Exception e) {
+      return protocol.clientbound.getProtocolRegistry(version).getPacketId(
+          (Class<? extends MinecraftPacket>) packet.getClass().getSuperclass());
+    }
+  }
+
+  public ByteBuf getBuffer(ProtocolVersion version) {
+    ByteBufHolder holder = packets.get(version);
+    return holder == null ? null : holder.byteBuf.retainedSlice();
+  }
+
+
+  public int getBufferLength(ProtocolVersion version) {
+    ByteBufHolder holder = packets.get(version);
+    return holder == null ? 0 : holder.byteBuf.readableBytes();
+  }
+
+  public void selfWrite(MinecraftConnection mc, boolean flush) {
+    if (packets.containsKey(mc.getProtocolVersion())) {
+      if (flush) {
+        mc.write(this);
+      } else {
+        mc.delayedWrite(this);
+      }
+    }
+  }
+
+  public boolean isFinished() {
+    return finished;
+  }
+
+
+  private ByteBufHolder getHolder(ByteBuf buf, ProtocolVersion version) {
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      ByteBufHolder holder = packets.get(ProtocolVersion.MINECRAFT_1_7_2);
+      if (holder != null && holder.byteBuf.equals(buf)) {
+        buf.release();
+        return holder;
+      }
+      return new ByteBufHolder(true, buf);
+    }
+
+    for (ByteBufHolder holder : new HashSet<>(packets.values())) {
+      if (!holder.mc1_7 && holder.byteBuf.equals(buf)) {
+        buf.release();
+        return holder;
+      }
+    }
+    return new ByteBufHolder(false, buf);
+  }
+
+
+  public void processCompress(PacketCompressor packetCompressor) {
+    if (finished) {
+      throw new IllegalStateException("Packet compression does not allowed after adapt");
+    }
+    for (Entry<ProtocolVersion, ByteBufHolder> prepared : packets.entrySet()) {
+      ByteBufHolder holder = prepared.getValue();
+      if (holder.mc1_7 || holder.compressed) {
+        continue;
+      }
+      ByteBuf current = holder.byteBuf;
+      ByteBuf newBuf;
+      int bytes = current.readableBytes();
+      holder.compressed = true;
+      if (packetCompressor.shouldCompress(bytes)) {
+        newBuf = packetCompressor.compress(current);
+      } else {
+        newBuf = ByteBufCreator.newBuffer(2 + current.readableBytes());
+        ProtocolUtils.writeVarInt(newBuf, 0);
+        newBuf.writeBytes(current);
+      }
+      newBuf.capacity(newBuf.readableBytes());
+      holder.byteBuf = newBuf;
+    }
+  }
+
+  public void finish() {
+    for (Entry<ProtocolVersion, ByteBufHolder> prepared : packets.entrySet()) {
+      ByteBufHolder holder = prepared.getValue();
+      if (holder.varint) {
+        continue;
+      }
+      ByteBuf current = holder.byteBuf;
+      ByteBuf buf = ByteBufCreator.newBuffer(5 + current.readableBytes());
+      ProtocolUtils.writeVarInt(buf, current.readableBytes());
+      buf.writeBytes(current);
+      buf.capacity(buf.readableBytes());
+      ReferenceCountUtil.safeRelease(current);
+      holder.byteBuf = buf;
+      holder.varint = true;
+    }
+    finished = true;
+  }
+
+  public void releaseBuffers() {
+    for (ByteBufHolder holder : new HashSet<>(packets.values())) {
+      holder.byteBuf.release();
+    }
+  }
+
+  private static class ByteBufHolder {
+
+    private final boolean mc1_7;
+    private ByteBuf byteBuf;
+    private boolean compressed = false;
+    private boolean varint = false;
+
+    public ByteBufHolder(boolean mc1_7, ByteBuf byteBuf) {
+      this.mc1_7 = mc1_7;
+      this.byteBuf = byteBuf;
+      if (mc1_7) {
+        compressed = true;
+      }
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/netty/MultiplePreparedPacketsEncoder.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/netty/MultiplePreparedPacketsEncoder.java
new file mode 100644
index 00000000..374119e5
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/netty/MultiplePreparedPacketsEncoder.java
@@ -0,0 +1,73 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.cache.netty;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+import lombok.RequiredArgsConstructor;
+import ru.leymooo.botfilter.protocol.cache.MultiplePreparedPackets;
+
+@Sharable
+@RequiredArgsConstructor
+public class MultiplePreparedPacketsEncoder extends
+    MessageToMessageEncoder<MultiplePreparedPackets> {
+
+
+  private static Map<ProtocolVersion, MultiplePreparedPacketsEncoder> encoders = new EnumMap<>(
+      ProtocolVersion.class);
+
+  static {
+    for (ProtocolVersion version : ProtocolVersion.SUPPORTED_VERSIONS) {
+      encoders.put(version, new MultiplePreparedPacketsEncoder(version));
+    }
+  }
+
+  private final ProtocolVersion protocolVersion;
+
+
+  @Override
+  protected void encode(ChannelHandlerContext ctx, MultiplePreparedPackets msg, List<Object> out)
+      throws Exception {
+    System.out.println("Processing multiple encoder");
+    ByteBuf buf = msg.getBuffer(protocolVersion);
+    out.add(buf);
+  }
+
+  /*
+  @Override
+  protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, MultiplePreparedPackets msg,
+      boolean preferDirect) throws Exception {
+    int length = msg.getBuffetLength(protocolVersion);
+    return ByteBufCreator.isDirectBufferPreferred() ? ctx.alloc().directBuffer(length)
+        : ctx.alloc().heapBuffer(length);
+  }
+
+   */
+
+
+  public static MultiplePreparedPacketsEncoder getEncoder(ProtocolVersion version) {
+    return encoders.get(version);
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/netty/PreparedPacketEncoder.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/netty/PreparedPacketEncoder.java
new file mode 100644
index 00000000..79a53105
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/cache/netty/PreparedPacketEncoder.java
@@ -0,0 +1,79 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.cache.netty;
+
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.Table;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.natives.encryption.JavaVelocityCipher;
+import com.velocitypowered.natives.util.Natives;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import java.util.List;
+import lombok.RequiredArgsConstructor;
+import ru.leymooo.botfilter.protocol.cache.PreparedPacket;
+
+@Sharable
+@RequiredArgsConstructor
+public class PreparedPacketEncoder extends MessageToMessageEncoder<PreparedPacket> {
+
+
+  private static final boolean IS_JAVA_CIPHER = Natives.cipher.get() == JavaVelocityCipher.FACTORY;
+  private static Table<ProtocolVersion, Boolean, PreparedPacketEncoder> encoders = HashBasedTable
+      .create(ProtocolVersion.SUPPORTED_VERSIONS.size(), 2);
+
+
+  static {
+    for (ProtocolVersion version : ProtocolVersion.SUPPORTED_VERSIONS) {
+      encoders.put(version, true, new PreparedPacketEncoder(version, true));
+      encoders.put(version, false, new PreparedPacketEncoder(version, false));
+    }
+  }
+
+  private final ProtocolVersion protocolVersion;
+  private final boolean onlineMode;
+
+
+  @Override
+  protected void encode(ChannelHandlerContext ctx, PreparedPacket msg, List<Object> out)
+      throws Exception {
+    System.out.println("Processing prepared");
+    ByteBuf buf = msg.getBuffer(protocolVersion);
+    out.add(buf);
+  }
+
+  /*
+
+  @Override
+  protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, PreparedPacket msg,
+      boolean preferDirect) throws Exception {
+    int length = msg.getBufferLength(protocolVersion);
+    boolean direct = onlineMode ? IS_JAVA_CIPHER : ByteBufCreator.isDirectBufferPreferred();
+    return direct ? ctx.alloc().directBuffer(length) : ctx.alloc().heapBuffer(length);
+  }
+
+   */
+
+
+  public static PreparedPacketEncoder getEncoder(ProtocolVersion version, boolean onlineMode) {
+    return encoders.get(version, onlineMode);
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/Biome.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/Biome.java
new file mode 100644
index 00000000..40aceee4
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/Biome.java
@@ -0,0 +1,231 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.data.registry;
+
+import javax.annotation.Nullable;
+import lombok.Data;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import net.kyori.adventure.nbt.CompoundBinaryTag.Builder;
+import ru.leymooo.botfilter.protocol.data.registry.Biome.Effects.MoodSound;
+
+public class Biome {
+
+  public static final Biome PLAINTS = new Biome("minecraft:plains", 1,
+      new Element("rain", 0.125f, 0.8f, 0.05f, 0.4f, "plains",
+          Effects.builder(7907327, 329011, 12638463, 415920)
+              .moodSound(MoodSound.of(6000, 2.0d, 8, "minecraft:ambient.cave")).build()));
+
+  public static final Biome SWAMP = new Biome("minecraft:swamp", 6,
+      new Element("rain", -0.2F, 0.8f, 0.1F, 0.9F, "swamp",
+          Effects.builder(7907327, 329011, 12638463, 415920).grassColorModifier("swamp")
+              .foliageColor(6975545)
+              .moodSound(MoodSound.of(6000, 2.0d, 8, "minecraft:ambient.cave")).build()));
+
+  public static final Biome SWAMP_HILLS = new Biome("minecraft:swamp_hills", 134,
+      new Element("rain", -0.1F, 0.8f, 0.3F, 0.9F, "swamp",
+          Effects.builder(7907327, 329011, 12638463, 415920).grassColorModifier("swamp")
+              .foliageColor(6975545)
+              .moodSound(MoodSound.of(6000, 2.0d, 8, "minecraft:ambient.cave")).build()));
+  public final String name;
+  public final int id;
+  public final Element element;
+
+
+  public Biome(String name, int id, Element element) {
+    this.name = name;
+    this.id = id;
+    this.element = element;
+  }
+
+  public CompoundBinaryTag encodeBiome() {
+    return CompoundBinaryTag.builder()
+        .putString("name", name)
+        .putInt("id", id)
+        .put("element", element.encode()).build();
+  }
+
+
+  public static class Element {
+
+    public final String precipitation;
+    public final float depth;
+    public final float temperature;
+    public final float scale;
+    public final float downfall;
+    public final String category;
+    public final Effects effects;
+
+    public Element(String precipitation, float depth, float temperature, float scale,
+        float downfall,
+        String category, Effects effects) {
+      this.precipitation = precipitation;
+      this.depth = depth;
+      this.temperature = temperature;
+      this.scale = scale;
+      this.downfall = downfall;
+      this.category = category;
+      this.effects = effects;
+    }
+
+    public CompoundBinaryTag encode() {
+      return CompoundBinaryTag.builder()
+          .putString("precipitation", precipitation)
+          .putFloat("depth", depth)
+          .putFloat("temperature", temperature)
+          .putFloat("scale", scale)
+          .putFloat("downfall", downfall)
+          .putString("category", category)
+          .put("effects", effects.encode()).build();
+    }
+  }
+
+  @Data
+  @RequiredArgsConstructor
+  @lombok.Builder
+  public static class Effects {
+
+    private final int skyColor;
+    private final int waterFogColor;
+    private final int fogColor;
+    private final int waterColor;
+
+    @Nullable private final Integer foliageColor;
+    @Nullable private final String grassColorModifier;
+    @Nullable private final Music music;
+    @Nullable private final String ambientSound;
+    @Nullable private final AdditionsSound additionsSound;
+    @Nullable private final MoodSound moodSound;
+    @Nullable private final Particle particle;
+
+    public CompoundBinaryTag encode() {
+      Builder result = CompoundBinaryTag.builder();
+      result.putInt("sky_color", skyColor)
+          .putInt("water_fog_color", waterColor)
+          .putInt("fog_color", fogColor)
+          .putInt("water_color", waterColor);
+
+      if (foliageColor != null) {
+        result.putInt("foliage_color", foliageColor);
+      }
+      if (grassColorModifier != null) {
+        result.putString("grass_color_modifier", grassColorModifier);
+      }
+      if (music != null) {
+        result.put("music", music.encode());
+      }
+      if (ambientSound != null) {
+        result.putString("ambient_sound", ambientSound);
+      }
+      if (additionsSound != null) {
+        result.put("additions_sound", additionsSound.encode());
+      }
+      if (moodSound != null) {
+        result.put("mood_sound", moodSound.encode());
+      }
+      if (particle != null) {
+        result.put("particle", particle.encode());
+      }
+      return result.build();
+    }
+
+    public static EffectsBuilder builder(int skyColor, int waterFogColor, int fogColor,
+        int waterColor) {
+      return new EffectsBuilder().skyColor(skyColor).waterFogColor(waterFogColor).fogColor(fogColor)
+          .waterColor(waterColor);
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class MoodSound {
+
+      private final int tickDelay;
+      private final double offset;
+      private final int blockSearchExtent;
+      @NonNull private final String sound;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putInt("tick_delay", tickDelay)
+            .putDouble("offset", offset)
+            .putInt("block_search_extent", blockSearchExtent)
+            .putString("sound", sound).build();
+      }
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class Music {
+
+      private final boolean replaceCurrentMusic;
+      @NonNull private final String sound;
+      private final int maxDelay;
+      private final int minDelay;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putBoolean("replace_current_music", replaceCurrentMusic)
+            .putString("sound", sound)
+            .putInt("max_delay", maxDelay)
+            .putInt("min_delay", minDelay).build();
+      }
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class AdditionsSound {
+
+      @NonNull private final String sound;
+      private final double tickChance;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putString("sound", sound)
+            .putDouble("tick_chance", tickChance).build();
+      }
+    }
+
+    @Data
+    @RequiredArgsConstructor(staticName = "of")
+    public static class Particle {
+
+      private final float probability;
+      @NonNull private final ParticleOptions options;
+
+      public CompoundBinaryTag encode() {
+        return CompoundBinaryTag.builder()
+            .putFloat("probability", probability)
+            .put("options", options.encode()).build();
+      }
+
+      @Data
+      @RequiredArgsConstructor
+      public static class ParticleOptions {
+
+        @NonNull private final String type;
+
+        public CompoundBinaryTag encode() {
+          return CompoundBinaryTag.builder()
+              .putString("type", type).build();
+        }
+      }
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/Dimension.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/Dimension.java
new file mode 100644
index 00000000..d2e32419
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/Dimension.java
@@ -0,0 +1,97 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.data.registry;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NonNull;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import net.kyori.adventure.nbt.CompoundBinaryTag.Builder;
+
+
+@AllArgsConstructor
+@Data
+public class Dimension {
+
+  public static final Dimension OVERWORLD = new Dimension("minecraft:overworld", 0, false, true,
+      0.0f, null, false, "minecraft:infiniburn_overworld",
+      false, true, true, "minecraft:overworld", true, 0, 256, 256, 1.0f, false, false);
+
+  @NonNull
+  private final String key;
+  private final int id;
+
+  private final boolean piglinSafe;
+  private final boolean natural;
+  private final float ambientLight;
+  private final Long fixedTime;
+  private final boolean shrunk;
+  @NonNull
+  private final String infiniburn;
+  private final boolean respawnAnchorWorks;
+  private final boolean hasSkylight;
+  private final boolean bedWorks;
+  @NonNull
+  private final String effects;
+  private final boolean hasRaids;
+  private final int minY;
+  private final int height;
+  private final int logicalHeight;
+  private final float coordinateScale;
+  private final boolean ultrawarm;
+  private final boolean hasCeiling;
+
+
+  public CompoundBinaryTag encodeAttributes(ProtocolVersion protocolVersion) {
+    Builder tag = CompoundBinaryTag.builder()
+        .putString("name", key)
+        .putBoolean("natural", natural)
+        .putBoolean("has_skylight", hasSkylight)
+        .putBoolean("has_ceiling", hasCeiling);
+    if (fixedTime != null) {
+      tag.putLong("fixed_time", fixedTime);
+    }
+
+    tag.putBoolean("shrunk", shrunk)
+        .putFloat("ambient_light", ambientLight)
+        .putBoolean("ultrawarm", ultrawarm)
+        .putBoolean("has_raids", hasRaids)
+        .putBoolean("respawn_anchor_works", respawnAnchorWorks)
+        .putBoolean("bed_works", bedWorks)
+        .putBoolean("piglin_safe", piglinSafe)
+        .putString("infiniburn", infiniburn)
+        .putInt("logical_height", logicalHeight);
+
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+      tag.remove("name")
+          .remove("shrunk")
+          .putString("effects", effects)
+          .putFloat("coordinate_scale", coordinateScale);
+    }
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_17)) {
+      tag.putInt("min_y", minY);
+      tag.putInt("height", height);
+    }
+
+    return tag.build();
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/DimensionRegistry.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/DimensionRegistry.java
new file mode 100644
index 00000000..858d6a97
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/registry/DimensionRegistry.java
@@ -0,0 +1,133 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.data.registry;
+
+import com.google.common.base.Preconditions;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.stream.Collectors;
+import net.kyori.adventure.nbt.BinaryTagTypes;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import net.kyori.adventure.nbt.ListBinaryTag;
+
+public class DimensionRegistry {
+
+  private final Map<Dimension, List<Biome>> dimensions = new HashMap<>();
+  private Dimension activeDimension;
+  private DimensionInfo activeDimensionInfo;
+
+  public void addDimension(Dimension dimension, List<Biome> biomes) {
+    Preconditions.checkNotNull(dimension);
+    Preconditions.checkNotNull(biomes);
+    Preconditions.checkState(!biomes.isEmpty());
+    dimensions.put(dimension, biomes);
+  }
+
+  public void removeDimension(Dimension dimension) {
+    dimensions.remove(dimension);
+  }
+
+  public Dimension getDimension(int id) {
+    return dimensions.keySet().stream().filter(dim -> dim.getId() == id).findAny().orElse(null);
+  }
+
+  public Dimension getDimension(String key) {
+    return dimensions.keySet().stream().filter(dim -> key.equals(dim.getKey())).findAny()
+        .orElse(null);
+  }
+
+  public List<Biome> getBiomes(Dimension dimension) {
+    return dimensions.get(dimension);
+  }
+
+  public List<String> getWorldNames() {
+    return dimensions.keySet().stream().map(dim -> dim.getKey()).collect(Collectors.toList());
+  }
+
+  public Dimension getActiveDimension() {
+    return activeDimension;
+  }
+
+  public void setActiveDimension(Dimension activeDimension) {
+    Preconditions
+        .checkState(dimensions.containsKey(activeDimension), "Dimension does not registered");
+    this.activeDimension = activeDimension;
+  }
+
+  public DimensionInfo getActiveDimensionInfo() {
+    return activeDimensionInfo;
+  }
+
+  public void setActiveDimensionInfo(DimensionInfo activeDimensionInfo) {
+    Preconditions.checkState(activeDimension != null, "Active dimension does not set");
+    this.activeDimensionInfo = activeDimensionInfo;
+  }
+
+  public CompoundBinaryTag encode(ProtocolVersion protocolVersion) {
+    ListBinaryTag.Builder<CompoundBinaryTag> dimensionsBuilder = ListBinaryTag
+        .builder(BinaryTagTypes.COMPOUND);
+    for (Entry<Dimension, List<Biome>> dimensionEntry : dimensions.entrySet()) {
+      Dimension dimension = dimensionEntry.getKey();
+      CompoundBinaryTag attributes = dimension.encodeAttributes(protocolVersion);
+      if (protocolVersion.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_16_1)) {
+        dimensionsBuilder.add(attributes);
+      } else {
+        CompoundBinaryTag dimensionData = CompoundBinaryTag.builder()
+            .putString("name", dimension.getKey())
+            .putInt("id", dimension.getId())
+            .put("element", attributes).build();
+        dimensionsBuilder.add(dimensionData);
+      }
+    }
+    if (protocolVersion.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_16_1)) {
+      return CompoundBinaryTag.builder().put("dimension", dimensionsBuilder.build()).build();
+    } else {
+      CompoundBinaryTag encodedDimensions = CompoundBinaryTag.builder()
+          .putString("type", "minecraft:dimension_type")
+          .put("value", dimensionsBuilder.build())
+          .build();
+      return CompoundBinaryTag.builder()
+          .put("minecraft:dimension_type", encodedDimensions)
+          .put("minecraft:worldgen/biome", createBiomeRegistry(dimensions.values())).build();
+    }
+  }
+
+  private CompoundBinaryTag createBiomeRegistry(Collection<List<Biome>> allBiomes) {
+    Set<Biome> biomes = new HashSet<>();
+    for (List<Biome> biomeLise : allBiomes) {
+      biomes.addAll(biomeLise);
+    }
+
+    ListBinaryTag.Builder<CompoundBinaryTag> biomesBuilder = ListBinaryTag
+        .builder(BinaryTagTypes.COMPOUND);
+    for (Biome biome : biomes) {
+      biomesBuilder.add(biome.encodeBiome());
+    }
+    return CompoundBinaryTag.builder()
+        .putString("type", "minecraft:worldgen/biome")
+        .put("value", biomesBuilder.build()).build();
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage.java
new file mode 100644
index 00000000..9765bbca
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage.java
@@ -0,0 +1,53 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.data.storage;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import io.netty.buffer.ByteBuf;
+import lombok.NonNull;
+import org.jetbrains.annotations.NotNull;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.SimpleBlock.Version;
+
+public interface BlockStorage {
+
+
+  void set(int x, int y, int z, @NonNull SimpleBlock block);
+
+  @NotNull SimpleBlock get(int x, int y, int z);
+
+  void write(ByteBuf buf, ProtocolVersion version);
+
+  int getDataLength(ProtocolVersion version);
+
+  BlockStorage copy();
+
+  static int index(int x, int y, int z) {
+    return y << 8 | z << 4 | x;
+  }
+
+  static BlockStorage create(Version version) {
+    if (version.isBefore(Version.MINECRAFT_1_9)) {
+      return new BlockStorage17();
+    } else {
+      return new BlockStorage19(version);
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage17.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage17.java
new file mode 100644
index 00000000..1818cfb3
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage17.java
@@ -0,0 +1,109 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.data.storage;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.netty.buffer.ByteBuf;
+import java.util.Arrays;
+import lombok.AccessLevel;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import org.jetbrains.annotations.NotNull;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.SimpleBlock.Version;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk;
+
+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
+public class BlockStorage17 implements BlockStorage {
+
+  private final SimpleBlock[] blocks;
+  private int pass = 0;
+
+  public BlockStorage17() {
+    this(new SimpleBlock[SimpleChunk.MAX_BLOCKS_PER_SECTION]);
+  }
+
+  @Override
+  public void set(int x, int y, int z, @NonNull SimpleBlock block) {
+    blocks[BlockStorage.index(x, y, z)] = block;
+  }
+
+  @SuppressFBWarnings("NP_NONNULL_RETURN_VIOLATION")
+  @Override
+  public @NotNull SimpleBlock get(int x, int y, int z) {
+    SimpleBlock block = blocks[BlockStorage.index(x, y, z)];
+    return block == null ? SimpleBlock.AIR : block;
+  }
+
+  @Override
+  public void write(ByteBuf buf, ProtocolVersion version) {
+    if (pass == 0) {
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+        writeBlocks17(buf);
+      } else {
+        writeBlocks18(buf);
+      }
+      pass++;
+    } else if (pass == 1) {
+      NibbleArray3d metadata = new NibbleArray3d(16 * 16 * 16);
+      for (int i = 0; i < blocks.length; i++) {
+        metadata.set(i, blocks[i] == null ? 0 : blocks[i].getData(Version.MINECRAFT_1_7));
+      }
+      buf.writeBytes(metadata.getData());
+      pass = 0;
+    }
+  }
+
+  @Override
+  public BlockStorage copy() {
+    return new BlockStorage17(Arrays.copyOf(blocks, blocks.length));
+  }
+
+  private void writeBlocks17(ByteBuf buf) {
+    byte[] raw = new byte[blocks.length];
+    for (int i = 0; i < blocks.length; i++) {
+      SimpleBlock block = blocks[i];
+      raw[i] = (byte) (block == null ? 0 : block.getId(Version.MINECRAFT_1_7));
+    }
+    buf.writeBytes(raw);
+  }
+
+  private void writeBlocks18(ByteBuf buf) {
+    short[] raw = new short[blocks.length];
+    for (int i = 0; i < blocks.length; i++) {
+      SimpleBlock block = blocks[i];
+      raw[i] = (short) (block == null ? 0
+          : (block.getId(Version.MINECRAFT_1_8) << 4 | block.getData(Version.MINECRAFT_1_8)));
+    }
+    for (Short s : raw) {
+      buf.writeShortLE(s);
+    }
+  }
+
+  @Override
+  public int getDataLength(ProtocolVersion version) {
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      return blocks.length + (SimpleChunk.MAX_BLOCKS_PER_SECTION >> 1);
+    } else {
+      return blocks.length * 2;
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage19.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage19.java
new file mode 100644
index 00000000..8ac158a2
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/data/storage/BlockStorage19.java
@@ -0,0 +1,185 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.data.storage;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.netty.buffer.ByteBuf;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import lombok.AccessLevel;
+import lombok.AllArgsConstructor;
+import lombok.NonNull;
+import org.jetbrains.annotations.NotNull;
+import ru.leymooo.botfilter.protocol.util.CompactStorage;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.BitStorage116;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.BitStorage19;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.SimpleBlock.Version;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk;
+
+@AllArgsConstructor(access = AccessLevel.PRIVATE)
+public class BlockStorage19 implements BlockStorage {
+
+  private final Version version;
+  private List<SimpleBlock> palette = new ArrayList<>();
+  private Map<Integer, SimpleBlock> rawToBlock = new HashMap<>();
+  private CompactStorage storage;
+
+  public BlockStorage19(Version version) {
+    this.version = version;
+    this.storage = createStorage(4);
+    palette.add(SimpleBlock.AIR);
+    rawToBlock.put(toRaw(SimpleBlock.AIR, version), SimpleBlock.AIR);
+  }
+
+  public void set(int x, int y, int z, @NonNull SimpleBlock block) {
+    int id = getIndex(block);
+    storage.set(index(x, y, z), id);
+  }
+
+  @SuppressFBWarnings("NP_NONNULL_RETURN_VIOLATION")
+  public @NotNull SimpleBlock get(int x, int y, int z) {
+    return get(index(x, y, z));
+  }
+
+  private SimpleBlock get(int index) {
+    int id = storage.get(index);
+
+    if (storage.getBitsPerEntry() > 8) {
+      return rawToBlock.get(id);
+    } else {
+      return palette.get(id);
+    }
+  }
+
+  @Override
+  public void write(ByteBuf buf, ProtocolVersion version) {
+    buf.writeByte(storage.getBitsPerEntry());
+    if (storage.getBitsPerEntry() > 8) {
+      if (this.version.isBefore(Version.MINECRAFT_1_13)) {
+        ProtocolUtils.writeVarInt(buf, 0);
+      }
+    } else {
+      ProtocolUtils.writeVarInt(buf, palette.size());
+      for (SimpleBlock state : palette) {
+        ProtocolUtils.writeVarInt(buf, toRaw(state, this.version));
+      }
+    }
+    storage.write(buf, version);
+  }
+
+  @Override
+  public int getDataLength(ProtocolVersion version) {
+    int length = 1;
+    if (storage.getBitsPerEntry() > 8) {
+      if (this.version.isBefore(Version.MINECRAFT_1_13)) {
+        length += 1;
+      }
+    } else {
+      length += ProtocolUtils.varIntBytes(palette.size());
+      for (SimpleBlock state : palette) {
+        length += ProtocolUtils.varIntBytes(toRaw(state, this.version));
+      }
+    }
+    return length + storage.getDataLength();
+  }
+
+
+  private int getIndex(SimpleBlock block) {
+    if (storage.getBitsPerEntry() > 8) {
+      int raw = toRaw(block, version);
+      rawToBlock.put(raw, block);
+      return raw;
+    }
+    int id = palette.indexOf(block);
+    if (id == -1) {
+      if (palette.size() >= (1 << storage.getBitsPerEntry())) {
+        resize(storage.getBitsPerEntry() + 1);
+        return getIndex(block);
+      }
+      palette.add(block);
+      id = palette.size() - 1;
+    }
+    return id;
+  }
+
+  @Override
+  public BlockStorage copy() {
+    return new BlockStorage19(version, new ArrayList<>(palette), new HashMap<>(rawToBlock),
+        storage.copy());
+  }
+
+  private void resize(int newSize) {
+    newSize = fixBitsPerEntry(newSize);
+    CompactStorage newStorage = createStorage(newSize);
+
+    for (int i = 0; i < SimpleChunk.MAX_BLOCKS_PER_SECTION; i++) {
+      int newId = newSize > 8 ? toRaw(palette.get(storage.get(i)), version) : storage.get(i);
+      newStorage.set(i, newId);
+    }
+    this.storage = newStorage;
+  }
+
+  private int fixBitsPerEntry(int newSize) {
+    if (newSize < 4) {
+      return 4;
+    } else if (newSize < 9) {
+      return newSize;
+    } else if (version.isBefore(Version.MINECRAFT_1_13)) {
+      return 13;
+    } else if (version.isBefore(Version.MINECRAFT_1_16_4)) {
+      return 14;
+    } else {
+      return 15;
+    }
+  }
+
+  private CompactStorage createStorage(int bits) {
+    return version.isBefore(Version.MINECRAFT_1_16)
+        ? new BitStorage19(bits, SimpleChunk.MAX_BLOCKS_PER_SECTION)
+        : new BitStorage116(bits, SimpleChunk.MAX_BLOCKS_PER_SECTION);
+  }
+
+  @Override
+  public String toString() {
+    return "BlockStorage19{"
+        + "version=" + version
+        + ", palette=" + palette
+        + ", rawToBlock=" + rawToBlock
+        + ", storage=" + storage
+        + '}';
+  }
+
+  private static int toRaw(SimpleBlock state, Version version) {
+    if (version.isBefore(Version.MINECRAFT_1_13)) {
+      return (state.getId(version) << 4) | (state.getData(version) & 0xF);
+    } else {
+      return state.getId(version);
+    }
+  }
+
+  private static int index(int x, int y, int z) {
+    return y << 8 | z << 4 | x;
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/JoinGame.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/JoinGame.java
new file mode 100644
index 00000000..a2264fb3
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/JoinGame.java
@@ -0,0 +1,113 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.packet;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.Setter;
+import lombok.ToString;
+import ru.leymooo.botfilter.protocol.data.registry.DimensionRegistry;
+
+
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+public class JoinGame implements MinecraftPacket {
+
+  private int entityId;
+  private short gamemode;
+  private int dimension;
+  private long partialHashedSeed;
+  private short difficulty;
+  private boolean hardcore;
+  private int maxPlayers;
+  private String levelType;
+  private int viewDistance;
+  private boolean reducedDebugInfo;
+  private boolean showRespawnScreen;
+  private DimensionRegistry dimensionRegistry;
+  private short previousGamemode;
+
+
+  @Override
+  public void encode(ByteBuf buf, ProtocolUtils.Direction direction, ProtocolVersion version) {
+    buf.writeInt(entityId);
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+      buf.writeBoolean(hardcore);
+      buf.writeByte(gamemode);
+    } else {
+      buf.writeByte(hardcore ? gamemode | 0x8 : gamemode);
+    }
+    DimensionInfo dimensionInfo = dimensionRegistry.getActiveDimensionInfo();
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16)) {
+      buf.writeByte(previousGamemode);
+      ProtocolUtils.writeStringArray(buf,
+          dimensionRegistry.getWorldNames().toArray(new String[0])); //worldNames
+      ProtocolUtils.writeCompoundTag(buf, dimensionRegistry.encode(version));
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+        ProtocolUtils.writeCompoundTag(buf,
+            dimensionRegistry.getActiveDimension().encodeAttributes(version));
+        ProtocolUtils.writeString(buf, dimensionInfo.getRegistryIdentifier());
+      } else {
+        ProtocolUtils.writeString(buf, dimensionInfo.getRegistryIdentifier());
+        ProtocolUtils.writeString(buf, dimensionInfo.getLevelName());
+      }
+    } else if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9_1)) {
+      buf.writeInt(dimension);
+    } else {
+      buf.writeByte(dimension);
+    }
+    if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_13_2)) {
+      buf.writeByte(difficulty);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+      buf.writeLong(partialHashedSeed);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+      ProtocolUtils.writeVarInt(buf, maxPlayers);
+    } else {
+      buf.writeByte(maxPlayers);
+    }
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_16)) {
+      ProtocolUtils.writeString(buf, levelType);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+      ProtocolUtils.writeVarInt(buf, viewDistance);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.writeBoolean(reducedDebugInfo);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+      buf.writeBoolean(showRespawnScreen);
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16)) {
+      buf.writeBoolean(dimensionInfo.isDebugType());
+      buf.writeBoolean(dimensionInfo.isFlat());
+    }
+  }
+}
\ No newline at end of file
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/PlayerPositionAndLook.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/PlayerPositionAndLook.java
new file mode 100644
index 00000000..895d5e51
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/PlayerPositionAndLook.java
@@ -0,0 +1,88 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.packet;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.Setter;
+import lombok.ToString;
+
+@Getter
+@Setter
+@AllArgsConstructor
+@NoArgsConstructor
+@ToString
+public class PlayerPositionAndLook implements MinecraftPacket {
+
+  private double x;
+  private double y;
+  private double z;
+  private float yaw;
+  private float pitch;
+  private int teleportId;
+  private boolean onGround;
+  private boolean dismountVehicle;
+
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    buf.writeDouble(this.x);
+    buf.writeDouble(this.y);
+    buf.writeDouble(this.z);
+    buf.writeFloat(this.yaw);
+    buf.writeFloat(this.pitch);
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.writeByte(0x00);
+    }
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9)) {
+      ProtocolUtils.writeVarInt(buf, teleportId);
+    }
+    if (protocolVersion.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.writeBoolean(onGround);
+    }
+    if (protocolVersion.isAfterOrEq(ProtocolVersion.MINECRAFT_1_17)) {
+      buf.writeBoolean(dismountVehicle);
+    }
+  }
+
+  @Override
+  public void decode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    this.x = buf.readDouble();
+    this.y = buf.readDouble();
+    if (protocolVersion.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+      buf.readDouble(); //Skip HeadY
+    }
+    this.z = buf.readDouble();
+    this.yaw = buf.readFloat();
+    this.pitch = buf.readFloat();
+    this.onGround = buf.readBoolean();
+  }
+
+  @Override
+  public boolean handle(MinecraftSessionHandler handler) {
+    return handler.handle(this);
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/UpdateViewPosition.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/UpdateViewPosition.java
new file mode 100644
index 00000000..6a7bad7f
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/UpdateViewPosition.java
@@ -0,0 +1,49 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.packet;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import lombok.Setter;
+import lombok.ToString;
+
+@Getter
+@Setter
+@AllArgsConstructor
+@NoArgsConstructor
+@ToString
+public class UpdateViewPosition implements MinecraftPacket {
+
+  private int chunkX;
+  private int chunkZ;
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    ProtocolUtils.writeVarInt(buf, chunkX);
+    ProtocolUtils.writeVarInt(buf, chunkZ);
+
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/Chunk17to115.old b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/Chunk17to115.old
new file mode 100644
index 00000000..f717e42a
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/Chunk17to115.old
@@ -0,0 +1,215 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.packet.world;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.zip.Deflater;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import ru.leymooo.botfilter.protocol.util.NetworkSection;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.FlexibleStorage;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk.ChunkSection;
+
+/**
+ * 1.7 - 1.15.2
+ */
+public class Chunk17to115 extends ChunkData {
+
+  private final SimpleChunk simpleChunk;
+  private final List<NetworkSection> networkSections = new ArrayList<>(16);
+
+  public Chunk17to115(SimpleChunk simpleChunk) {
+    super(simpleChunk.getX(), simpleChunk.getZ());
+    this.simpleChunk = simpleChunk;
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion version) {
+
+    //write data to out buffer
+    buf.writeInt(getX());
+    buf.writeInt(getZ());
+    buf.writeBoolean(true); //Full chunk
+
+    ByteBuf data = Unpooled.buffer(getInitialDataSize(version));
+    int mask = writeChunkData(data, version);
+
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9)) {
+      buf.ensureWritable(1024 * 4 + ((36 * 8) * 2) + 150);
+      ProtocolUtils.writeVarInt(buf, mask);
+
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+        ProtocolUtils.writeCompoundTag(buf, buildHeightMap());
+      }
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+        writeChunkBiomes(buf, version);
+      }
+      buf.ensureWritable(data.readableBytes() + 5 + 1);
+      ProtocolUtils.writeVarInt(buf, data.readableBytes());
+      buf.writeBytes(data);
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9_4)) {
+        ProtocolUtils.writeVarInt(buf, 0); // no tile entities nbts
+      }
+    } else {
+      buf.writeShort(mask); //Number of chunks
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+        write17(buf, data);
+      } else {
+        ProtocolUtils.writeVarInt(buf, data.readableBytes());
+        buf.writeBytes(data);
+      }
+    }
+    data.release();
+
+  }
+
+  private CompoundBinaryTag buildHeightMap() {
+    FlexibleStorage surface = new FlexibleStorage(9, 256);
+    FlexibleStorage motionBlocking = new FlexibleStorage(9, 256);
+
+    for (int y = 0; y < 256; y++) {
+      for (int x = 0; x < 16; x++) {
+        for (int z = 0; z < 16; z++) {
+          SimpleBlock block = simpleChunk.getBlock(x, y, z);
+          if (!block.isAir()) {
+            surface.set(x + z * 16, y + 1);
+          }
+          if (block.isMotionBlocking()) {
+            motionBlocking.set(x + z * 16, y + 1);
+          }
+        }
+      }
+    }
+    return CompoundBinaryTag.builder().putLongArray("MOTION_BLOCKING", motionBlocking.getData())
+        .putLongArray("WORLD_SURFACE", surface.getData()).build();
+  }
+
+
+  private int writeChunkData(ByteBuf data, ProtocolVersion version) {
+    networkSections.clear();
+    ChunkSection[] sections = simpleChunk.getSections();
+    List<NetworkSection> nSections = new ArrayList<>(16);
+    boolean skyLight = simpleChunk.getInstance().getDimension().isHasSkylight();
+    int bitMask = 0;
+    int dataLength = data.capacity();
+    //Calculate bitMask, data length and convert chunk sections to network sections
+    for (int s = 0; s < sections.length; s++) {
+      ChunkSection section = sections[s];
+      if (section != null && section.hasAnyData()) {
+        bitMask |= 1 << s;
+        NetworkSection networkSection = NetworkSection.create(version, section, skyLight);
+        dataLength += networkSection.getDataLength();
+        nSections.add(networkSection);
+      }
+    }
+
+    data.ensureWritable(dataLength); //resize buffer
+    //Write chunk sections data to buffer
+    for (int pass = 0; pass < 4; pass++) {
+      int finalPass = pass;
+      nSections.forEach(n -> n.writeData(data, finalPass));
+    }
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      writeChunkBiomes(data, version);
+    }
+    return bitMask;
+  }
+
+  private void writeChunkBiomes(ByteBuf data, ProtocolVersion version) {
+    Object biomes = createBiomesArray(version);
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_13)) {
+        data.ensureWritable(256);
+        data.writeBytes((byte[]) biomes);
+      } else {
+        data.ensureWritable(256 * 4);
+        for (byte b : (byte[]) biomes) {
+          data.writeInt(b);
+        }
+      }
+    } else {
+      data.ensureWritable(1024 * 4);
+      for (int i : ((int[]) biomes)) {
+        data.writeInt(i);
+      }
+    }
+  }
+
+  private Object createBiomesArray(ProtocolVersion version) {
+    ChunkSection[] sections = simpleChunk.getSections();
+    Object biomes = null;
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      biomes = new byte[256];
+      Arrays.fill((byte[]) biomes, (byte) 1);
+    } else {
+      biomes = new int[1024];
+      Arrays.fill((int[]) biomes, 1);
+    }
+    for (int s = 0; s < sections.length; s++) {
+      ChunkSection section = sections[s];
+      if (section != null) {
+        int biome = section.getBiome().id;
+        if (version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+          Arrays.fill((byte[]) biomes, s * 16, (s * 16) + 16, (byte) biome);
+        } else {
+          Arrays.fill((int[]) biomes, s * 16 * 4, (s * 16 * 4) + 64, biome);
+        }
+      }
+    }
+    return biomes;
+  }
+
+  private int getInitialDataSize(ProtocolVersion version) {
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_13)) {
+      return 256;
+    }
+    if (version.isBeforeOrEq(ProtocolVersion.MINECRAFT_1_14_4)) {
+      return 256 * 4;
+    }
+    return 0;
+  }
+
+  private void write17(ByteBuf out, ByteBuf data) {
+    out.writeShort(0); //Extended bitmask
+
+    byte[] uncompressed = new byte[data.readableBytes()];
+    data.readBytes(uncompressed);
+    ByteBuf compressed = Unpooled.buffer();
+    Deflater deflater = new Deflater(9);
+    deflater.setInput(uncompressed);
+    deflater.finish();
+    byte[] buffer = new byte[1024];
+    while (!deflater.finished()) {
+      int count = deflater.deflate(buffer);
+      compressed.writeBytes(buffer, 0, count);
+    }
+    deflater.end();
+    out.writeInt(compressed.readableBytes()); // compressed size
+    out.writeBytes(compressed);
+    compressed.release();
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/ChunkData.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/ChunkData.java
new file mode 100644
index 00000000..e8d02c0e
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/ChunkData.java
@@ -0,0 +1,278 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.packet.world;
+
+import com.google.common.base.Preconditions;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.ReferenceCountUtil;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.zip.Deflater;
+import lombok.Getter;
+import net.kyori.adventure.nbt.CompoundBinaryTag;
+import ru.leymooo.botfilter.protocol.data.registry.Biome;
+import ru.leymooo.botfilter.protocol.util.CompactStorage;
+import ru.leymooo.botfilter.protocol.util.NetworkSection;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.BitStorage116;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.BitStorage19;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.chunk.ChunkSnapshot;
+import ru.leymooo.botfilter.server.world.chunk.LightSection;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk;
+
+public class ChunkData implements MinecraftPacket {
+
+  private final ChunkSnapshot chunk;
+  private final List<NetworkSection> sections = new ArrayList<>(16);
+  private final int mask;
+  private final BiomeData biomeData;
+  private CompoundBinaryTag heightmap114;
+  private CompoundBinaryTag heightmap116;
+
+  public ChunkData(ChunkSnapshot chunkSnapshot, boolean skyLight) {
+    this.chunk = chunkSnapshot;
+    int mask = 0;
+    for (int i = 0; i < chunkSnapshot.getSections().length; i++) {
+      if (chunkSnapshot.getSections()[i] != null) {
+        mask |= 1 << i;
+        LightSection light = chunkSnapshot.getLight()[i];
+        NetworkSection section = new NetworkSection(chunkSnapshot.getSections()[i],
+            light.getBlockLight(), skyLight ? light.getSkyLight() : null);
+        sections.add(section);
+      }
+    }
+    this.mask = mask;
+    this.heightmap114 = createHeightMap(true);
+    this.heightmap116 = createHeightMap(false);
+    this.biomeData = new BiomeData(chunkSnapshot);
+  }
+
+  public ChunkData() {
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion version) {
+    if (!chunk.isFullChunk()) {
+      //1.17 supports only full chunks
+      Preconditions.checkState(version.isBefore(ProtocolVersion.MINECRAFT_1_17));
+    }
+    buf.writeInt(chunk.getX());
+    buf.writeInt(chunk.getZ());
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_17)) {
+      buf.writeBoolean(chunk.isFullChunk());
+
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16) &&
+          version.isBefore(ProtocolVersion.MINECRAFT_1_16_2)) {
+        buf.writeBoolean(true); //ignore old data
+      }
+
+      //mask
+      if (version.isAfter(ProtocolVersion.MINECRAFT_1_8)) {
+        ProtocolUtils.writeVarInt(buf, mask);
+      } else {
+        buf.writeShort(mask);
+      }
+    } else {
+      //1.17 mask
+      long[] mask = create117Mask();
+      ProtocolUtils.writeVarInt(buf, mask.length);
+      for (long m : mask) {
+        buf.writeLong(m);
+      }
+    }
+
+    //1.14+ HeightMap
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_16)) {
+        ProtocolUtils.writeCompoundTag(buf, heightmap114);
+      } else {
+        ProtocolUtils.writeCompoundTag(buf, heightmap116);
+      }
+    }
+
+    //1.15+ Biomes
+    if (chunk.isFullChunk() && version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_15)) {
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16_2)) {
+        ProtocolUtils.writeVarInt(buf, biomeData.getPost115Biomes().length);
+        for (int b : biomeData.getPost115Biomes()) {
+          ProtocolUtils.writeVarInt(buf, b);
+        }
+      } else {
+        for (int b : biomeData.getPost115Biomes()) {
+          buf.writeInt(b);
+        }
+      }
+    }
+    ByteBuf data = createChunkData(version);
+    try {
+      if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_8)) {
+        buf.ensureWritable(
+            data.readableBytes() + ProtocolUtils.varIntBytes(data.readableBytes()) + 1);
+        ProtocolUtils.writeVarInt(buf, data.readableBytes());
+        buf.writeBytes(data);
+        if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_9_4)) {
+          ProtocolUtils.writeVarInt(buf, 0); //Tile entities currently doesnt supported
+        }
+      } else {
+        write17(buf, data);
+      }
+    } finally {
+      ReferenceCountUtil.release(data);
+    }
+  }
+
+  private ByteBuf createChunkData(ProtocolVersion version) {
+    int dataLength = 0;
+    for (NetworkSection networkSection : sections) {
+      dataLength += networkSection.getDataLength(version);
+    }
+    if (chunk.isFullChunk() && version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      dataLength += (version.isBefore(ProtocolVersion.MINECRAFT_1_13) ? 256 : 256 * 4);
+    }
+
+    ByteBuf data = Unpooled.buffer(dataLength);
+    for (int pass = 0; pass < 4; pass++) {
+      int finalPass = pass;
+      sections.forEach(ns -> ns.writeData(data, finalPass, version));
+    }
+    if (chunk.isFullChunk() && version.isBefore(ProtocolVersion.MINECRAFT_1_15)) {
+      for (byte b : biomeData.getPre115Biomes()) {
+        if (version.isBefore(ProtocolVersion.MINECRAFT_1_13)) {
+          data.writeByte(b);
+        } else {
+          data.writeInt(b);
+        }
+      }
+    }
+
+    if (dataLength != data.readableBytes()) {
+      System.out.println(
+          "Data length missmatch: " + dataLength + " != " + data.readableBytes() + ". Version: "
+              + version);
+    }
+    return data;
+  }
+
+  private CompoundBinaryTag createHeightMap(boolean pre116) {
+    CompactStorage surface = pre116 ? new BitStorage19(9, 256) : new BitStorage116(9, 256);
+    CompactStorage motionBlocking = pre116 ? new BitStorage19(9, 256) : new BitStorage116(9, 256);
+
+    for (int y = 0; y < 256; y++) {
+      for (int x = 0; x < 16; x++) {
+        for (int z = 0; z < 16; z++) {
+          SimpleBlock block = chunk.getBlock(x, y, z);
+          if (!block.isAir()) {
+            surface.set(x + z * 16, y + 1);
+          }
+          if (block.isMotionBlocking()) {
+            motionBlocking.set(x + z * 16, y + 1);
+          }
+        }
+      }
+    }
+    return CompoundBinaryTag.builder().putLongArray("MOTION_BLOCKING", motionBlocking.getData())
+        .putLongArray("WORLD_SURFACE", surface.getData()).build();
+  }
+
+  private long[] create117Mask() {
+    BitSet bitSet = BitSet.valueOf(new long[]{mask});
+    return bitSet.toLongArray();
+  }
+
+  private void write17(ByteBuf out, ByteBuf data) {
+    out.writeShort(0); //Extended bitmask
+    byte[] uncompressed = new byte[data.readableBytes()];
+    data.readBytes(uncompressed);
+    ByteBuf compressed = Unpooled.buffer();
+    Deflater deflater = new Deflater(9);
+    try {
+      deflater.setInput(uncompressed);
+      deflater.finish();
+      byte[] buffer = new byte[1024];
+      while (!deflater.finished()) {
+        int count = deflater.deflate(buffer);
+        compressed.writeBytes(buffer, 0, count);
+      }
+      out.writeInt(compressed.readableBytes()); // compressed size
+      out.writeBytes(compressed);
+    } finally {
+      deflater.end();
+      compressed.release();
+    }
+
+  }
+
+  @Override
+  public void decode(ByteBuf buf, Direction direction, ProtocolVersion protocolVersion) {
+    throw new UnsupportedOperationException("should not be decoded");
+  }
+
+  @Override
+  public boolean handle(MinecraftSessionHandler handler) {
+    throw new UnsupportedOperationException("cant be called");
+  }
+
+  @Getter
+  private static class BiomeData {
+
+    private byte[] pre115Biomes = new byte[256];
+    private int[] post115Biomes = new int[1024];
+
+    public BiomeData(ChunkSnapshot chunk) {
+      Biome[] biomes = chunk.getBiomes();
+      for (int i = 0; i < biomes.length; i++) {
+        post115Biomes[i] = biomes[i].id;
+      }
+
+      //Down sample 4x4x4 3d biomes to 2d XZ
+      Map<Integer, Integer> samples = new HashMap<>(256 / 4);
+      for (int x = 0; x < 16; x += 4) {
+        for (int z = 0; z < 16; z += 4) {
+          samples.clear();
+          for (int y = 0; y < 256; y += 16) {
+            Biome biome = biomes[SimpleChunk.getBiomeIndex(x, y, z)];
+            int curr = samples.getOrDefault(biome.id, 0);
+            samples.put(biome.id, curr + 1);
+          }
+          int id = samples.entrySet().stream()
+              .max(Entry.comparingByValue())
+              .orElseThrow(RuntimeException::new).getKey();
+          for (int xl = x; xl < x + 4; xl++) {
+            for (int zl = z; zl < z + 4; zl++) {
+              this.pre115Biomes[zl * 16 + xl] = (byte) id;
+            }
+          }
+        }
+      }
+    }
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/UpdateLight.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/UpdateLight.java
new file mode 100644
index 00000000..cab358a2
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/packet/world/UpdateLight.java
@@ -0,0 +1,125 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.packet.world;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.MinecraftPacket;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import com.velocitypowered.proxy.protocol.ProtocolUtils.Direction;
+import io.netty.buffer.ByteBuf;
+import java.util.BitSet;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+import ru.leymooo.botfilter.server.world.chunk.ChunkSnapshot;
+import ru.leymooo.botfilter.server.world.chunk.LightSection;
+
+public class UpdateLight implements MinecraftPacket {
+
+  private final ChunkSnapshot chunk;
+  private final NibbleArray3d[] skyLight = new NibbleArray3d[18];
+  private final NibbleArray3d[] blockLight = new NibbleArray3d[18];
+  private int skyLightMask = 0;
+  private int blockLightMask = 0;
+  private int emptySkyLightMask = 0;
+  private int emptyBlockLightMask = 0;
+
+  private int skyLightArrayCount;
+  private int blockLightArrayCount;
+
+  public UpdateLight() {
+    chunk = null;
+  }
+
+  public UpdateLight(ChunkSnapshot chunkSnapshot) {
+    this.chunk = chunkSnapshot;
+    prepareLighting();
+  }
+
+  @Override
+  public void encode(ByteBuf buf, Direction direction, ProtocolVersion version) {
+    ProtocolUtils.writeVarInt(buf, chunk.getX());
+    ProtocolUtils.writeVarInt(buf, chunk.getZ());
+
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_16)) {
+      buf.writeBoolean(true); //trust edges
+    }
+
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_17)) {
+      ProtocolUtils.writeVarInt(buf, skyLightMask);
+      ProtocolUtils.writeVarInt(buf, blockLightMask);
+      ProtocolUtils.writeVarInt(buf, emptySkyLightMask);
+      ProtocolUtils.writeVarInt(buf, emptyBlockLightMask);
+    } else {
+      write117Mask(buf, skyLightMask);
+      write117Mask(buf, blockLightMask);
+      write117Mask(buf, emptySkyLightMask);
+      write117Mask(buf, emptyBlockLightMask);
+    }
+
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_17)) {
+      ProtocolUtils.writeVarInt(buf, skyLightArrayCount);
+    }
+    for (NibbleArray3d array3d : skyLight) {
+      if (array3d != null) {
+        ProtocolUtils.writeByteArray(buf, array3d.getData());
+      }
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_17)) {
+      ProtocolUtils.writeVarInt(buf, blockLightArrayCount);
+    }
+    for (NibbleArray3d nibbleArray3d : blockLight) {
+      if (nibbleArray3d != null) {
+        ProtocolUtils.writeByteArray(buf, nibbleArray3d.getData());
+      }
+    }
+  }
+
+  private void prepareLighting() {
+
+    LightSection[] lightSections = chunk.getLight();
+
+    for (int i = 0; i < lightSections.length; i++) {
+      LightSection section = lightSections[i];
+      if (section.getSkyLight() == LightSection.NO_LIGHT) {
+        emptySkyLightMask |= 1 << i;
+      } else if (section.getSkyLight() != LightSection.ALL_LIGHT) {
+        skyLightMask |= 1 << i;
+        skyLight[i] = section.getSkyLight();
+        skyLightArrayCount++;
+      }
+
+      if (section.getBlockLight() != LightSection.NO_LIGHT) {
+        blockLightMask |= 1 << i;
+        blockLight[i] = section.getBlockLight();
+        blockLightArrayCount++;
+      } else {
+        emptyBlockLightMask |= 1 << i;
+      }
+    }
+
+  }
+
+  private static void write117Mask(ByteBuf buf, int mask) {
+    BitSet bitSet = BitSet.valueOf(new long[]{mask});
+    long[] mk = bitSet.toLongArray();
+    ProtocolUtils.writeVarInt(buf, mk.length);
+    for (long m : mk) {
+      buf.writeLong(m);
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/CompactStorage.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/CompactStorage.java
new file mode 100644
index 00000000..dcca5cd5
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/CompactStorage.java
@@ -0,0 +1,40 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.util;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import io.netty.buffer.ByteBuf;
+
+public interface CompactStorage {
+
+
+  void set(int index, int value);
+
+  int get(int index);
+
+  void write(ByteBuf buf, ProtocolVersion version);
+
+  int getBitsPerEntry();
+
+  int getDataLength();
+
+  long[] getData();
+
+  CompactStorage copy();
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/NetworkSection.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/NetworkSection.java
new file mode 100644
index 00000000..3f249a97
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/NetworkSection.java
@@ -0,0 +1,154 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.protocol.util;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import io.netty.buffer.ByteBuf;
+import java.util.EnumMap;
+import java.util.Map;
+import lombok.NonNull;
+import ru.leymooo.botfilter.protocol.data.storage.BlockStorage;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.SimpleBlock.Version;
+import ru.leymooo.botfilter.server.world.chunk.SimpleSection;
+
+public class NetworkSection {
+
+  private final Map<ProtocolVersion, BlockStorage> storages = new EnumMap<>(ProtocolVersion.class);
+  private final NibbleArray3d blockLight;
+  private final NibbleArray3d skyLight;
+  private final SimpleSection section;
+  private int blockCount = -1;
+
+  public NetworkSection(SimpleSection section, @NonNull NibbleArray3d blockLight,
+      NibbleArray3d skyLight) {
+    this.section = section;
+    this.blockLight = blockLight;
+    this.skyLight = skyLight;
+  }
+
+  public BlockStorage ensureCreated(ProtocolVersion version) {
+    BlockStorage storage = storages.get(version);
+    if (storage == null) {
+      synchronized (storages) {
+        Version bVersion = Version.map(version);
+        BlockStorage blockStorage = BlockStorage.create(bVersion);
+        fillBlocks(blockStorage);
+        for (ProtocolVersion pVersion : bVersion.getVersions()) {
+          storages.put(pVersion, blockStorage);
+        }
+        storage = blockStorage;
+      }
+    }
+    return storage;
+  }
+
+  public int getDataLength(ProtocolVersion version) {
+    BlockStorage blockStorage = ensureCreated(version);
+
+    int dataLength = blockStorage.getDataLength(version);
+
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_14)) {
+      dataLength += blockLight.getData().length;
+      if (skyLight != null) {
+        dataLength += skyLight.getData().length;
+      }
+    }
+    if (version.isAfterOrEq(ProtocolVersion.MINECRAFT_1_14)) {
+      dataLength += 2; //Block count short
+    }
+
+    return dataLength;
+  }
+
+  public void writeData(ByteBuf data, int pass, ProtocolVersion version) {
+    if (version.isBefore(ProtocolVersion.MINECRAFT_1_9)) {
+      BlockStorage storage = ensureCreated(version);
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_8)) {
+        write17Data(data, pass, storage);
+      } else {
+        write18Data(data, pass, storage);
+      }
+    } else if (pass == 0) {
+      BlockStorage storage = ensureCreated(version);
+      if (version.isBefore(ProtocolVersion.MINECRAFT_1_14)) {
+        write19Data(data, storage, version);
+      } else {
+        write114Data(data, storage, version);
+      }
+    }
+  }
+
+  private void write17Data(ByteBuf data, int pass, BlockStorage storage) {
+    if (pass == 0) {
+      storage.write(data, ProtocolVersion.MINECRAFT_1_7_2);
+    } else if (pass == 1) {
+      storage.write(data, ProtocolVersion.MINECRAFT_1_7_2);
+    } else if (pass == 2) {
+      data.writeBytes(blockLight.getData());
+    } else if (pass == 3 && skyLight != null) {
+      data.writeBytes(skyLight.getData());
+    }
+  }
+
+  private void write18Data(ByteBuf data, int pass, BlockStorage storage) {
+    if (pass == 0) {
+      storage.write(data, ProtocolVersion.MINECRAFT_1_8);
+    } else if (pass == 1) {
+      data.writeBytes(blockLight.getData());
+    } else if (pass == 2 && skyLight != null) {
+      data.writeBytes(skyLight.getData());
+    }
+  }
+
+  private void write19Data(ByteBuf data, BlockStorage storage, ProtocolVersion version) {
+    storage.write(data, version);
+    data.writeBytes(blockLight.getData());
+    if (skyLight != null) {
+      data.writeBytes(skyLight.getData());
+    }
+  }
+
+  private void write114Data(ByteBuf data, BlockStorage storage, ProtocolVersion version) {
+    data.writeShort(blockCount);
+    storage.write(data, version);
+  }
+
+
+  private void fillBlocks(BlockStorage storage) {
+    int blockCount = 0;
+    for (int y = 0; y < 16; y++) {
+      for (int x = 0; x < 16; x++) {
+        for (int z = 0; z < 16; z++) {
+          SimpleBlock block = section.getBlockAt(x, y, z);
+          if (block.isAir()) {
+            continue;
+          }
+          blockCount++;
+          storage.set(x, y, z, block);
+        }
+      }
+    }
+    if (this.blockCount == -1) {
+      this.blockCount = blockCount;
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/BitStorage116.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/BitStorage116.java
new file mode 100644
index 00000000..e6c1bdea
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/BitStorage116.java
@@ -0,0 +1,164 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.leymooo.botfilter.protocol.util.mcprotocollib;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.netty.buffer.ByteBuf;
+import java.util.Arrays;
+import lombok.Getter;
+import ru.leymooo.botfilter.protocol.util.CompactStorage;
+
+public class BitStorage116 implements CompactStorage {
+
+  private static final int[] MAGIC_VALUES = {
+      -1, -1, 0, Integer.MIN_VALUE, 0, 0, 1431655765, 1431655765, 0, Integer.MIN_VALUE,
+      0, 1, 858993459, 858993459, 0, 715827882, 715827882, 0, 613566756, 613566756,
+      0, Integer.MIN_VALUE, 0, 2, 477218588, 477218588, 0, 429496729, 429496729, 0,
+      390451572, 390451572, 0, 357913941, 357913941, 0, 330382099, 330382099, 0, 306783378,
+      306783378, 0, 286331153, 286331153, 0, Integer.MIN_VALUE, 0, 3, 252645135, 252645135,
+      0, 238609294, 238609294, 0, 226050910, 226050910, 0, 214748364, 214748364, 0,
+      204522252, 204522252, 0, 195225786, 195225786, 0, 186737708, 186737708, 0, 178956970,
+      178956970, 0, 171798691, 171798691, 0, 165191049, 165191049, 0, 159072862, 159072862,
+      0, 153391689, 153391689, 0, 148102320, 148102320, 0, 143165576, 143165576, 0,
+      138547332, 138547332, 0, Integer.MIN_VALUE, 0, 4, 130150524, 130150524, 0, 126322567,
+      126322567, 0, 122713351, 122713351, 0, 119304647, 119304647, 0, 116080197, 116080197,
+      0, 113025455, 113025455, 0, 110127366, 110127366, 0, 107374182, 107374182, 0,
+      104755299, 104755299, 0, 102261126, 102261126, 0, 99882960, 99882960, 0, 97612893,
+      97612893, 0, 95443717, 95443717, 0, 93368854, 93368854, 0, 91382282, 91382282,
+      0, 89478485, 89478485, 0, 87652393, 87652393, 0, 85899345, 85899345, 0,
+      84215045, 84215045, 0, 82595524, 82595524, 0, 81037118, 81037118, 0, 79536431,
+      79536431, 0, 78090314, 78090314, 0, 76695844, 76695844, 0, 75350303, 75350303,
+      0, 74051160, 74051160, 0, 72796055, 72796055, 0, 71582788, 71582788, 0,
+      70409299, 70409299, 0, 69273666, 69273666, 0, 68174084, 68174084, 0, Integer.MIN_VALUE,
+      0, 5
+  };
+
+  private final long[] data;
+  @Getter
+  private final int bitsPerEntry;
+  @Getter
+  private final int size;
+
+  private final long maxValue;
+  private final int valuesPerLong;
+  private final long divideMultiply;
+  private final long divideAdd;
+  private final int divideShift;
+
+  public BitStorage116(int bitsPerEntry, int size) {
+    this(bitsPerEntry, size, null);
+  }
+
+  public BitStorage116(int bitsPerEntry, int size, long[] data) {
+    if (bitsPerEntry < 1 || bitsPerEntry > 32) {
+      throw new IllegalArgumentException("bitsPerEntry must be between 1 and 32, inclusive.");
+    }
+
+    this.bitsPerEntry = bitsPerEntry;
+    this.size = size;
+
+    this.maxValue = (1L << bitsPerEntry) - 1L;
+    this.valuesPerLong = (char) (64 / bitsPerEntry);
+    int expectedLength = (size + this.valuesPerLong - 1) / this.valuesPerLong;
+    if (data != null) {
+      if (data.length != expectedLength) {
+        throw new IllegalArgumentException(
+            "Expected " + expectedLength + " longs but got " + data.length + " longs");
+      }
+
+      this.data = Arrays.copyOf(data, data.length);
+    } else {
+      this.data = new long[expectedLength];
+    }
+
+    int magicIndex = 3 * (this.valuesPerLong - 1);
+    this.divideMultiply = Integer.toUnsignedLong(MAGIC_VALUES[magicIndex]);
+    this.divideAdd = Integer.toUnsignedLong(MAGIC_VALUES[magicIndex + 1]);
+    this.divideShift = MAGIC_VALUES[magicIndex + 2];
+  }
+
+  @Override
+  public int get(int index) {
+    if (index < 0 || index > this.size - 1) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    int cellIndex = cellIndex(index);
+    int bitIndex = bitIndex(index, cellIndex);
+    return (int) (this.data[cellIndex] >> bitIndex & this.maxValue);
+  }
+
+
+  @Override
+  public void set(int index, int value) {
+    if (index < 0 || index > this.size - 1) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    if (value < 0 || value > this.maxValue) {
+      throw new IllegalArgumentException("Value cannot be outside of accepted range.");
+    }
+
+    int cellIndex = cellIndex(index);
+    int bitIndex = bitIndex(index, cellIndex);
+    this.data[cellIndex] = this.data[cellIndex] & ~(this.maxValue << bitIndex)
+        | ((long) value & this.maxValue) << bitIndex;
+  }
+
+  private int cellIndex(int index) {
+    return (int) (index * this.divideMultiply + this.divideAdd >> 32 >> this.divideShift);
+  }
+
+  private int bitIndex(int index, int cellIndex) {
+    return (index - cellIndex * this.valuesPerLong) * this.bitsPerEntry;
+  }
+
+  @Override
+  public void write(ByteBuf buf, ProtocolVersion version) {
+    ProtocolUtils.writeVarInt(buf, data.length);
+    for (long l : data) {
+      buf.writeLong(l);
+    }
+  }
+
+  @Override
+  public int getDataLength() {
+    return ProtocolUtils.varIntBytes(data.length) + data.length * 8;
+  }
+
+  @Override
+  public CompactStorage copy() {
+    return new BitStorage116(bitsPerEntry, size, Arrays.copyOf(data, data.length));
+  }
+
+  @SuppressFBWarnings("EI_EXPOSE_REP")
+  @Override
+  public long[] getData() {
+    return data;
+  }
+}
\ No newline at end of file
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/BitStorage19.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/BitStorage19.java
new file mode 100644
index 00000000..b7b33b1e
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/BitStorage19.java
@@ -0,0 +1,149 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.leymooo.botfilter.protocol.util.mcprotocollib;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.protocol.ProtocolUtils;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.netty.buffer.ByteBuf;
+import java.util.Arrays;
+import ru.leymooo.botfilter.protocol.util.CompactStorage;
+
+@SuppressFBWarnings({"EI_EXPOSE_REP2", "EI_EXPOSE_REP"})
+public class BitStorage19 implements CompactStorage {
+
+  private final long[] data;
+  private final int bitsPerEntry;
+  private final int size;
+  private final long maxEntryValue;
+
+  public BitStorage19(int bitsPerEntry, int size) {
+    this(bitsPerEntry, new long[roundToNearest(size * bitsPerEntry, 64) / 64]);
+  }
+
+  public BitStorage19(int bitsPerEntry, long[] data) {
+    if (bitsPerEntry < 4) {
+      bitsPerEntry = 4;
+    }
+
+    this.bitsPerEntry = bitsPerEntry;
+    this.data = data;
+
+    this.size = this.data.length * 64 / this.bitsPerEntry;
+    this.maxEntryValue = (1L << this.bitsPerEntry) - 1;
+  }
+
+  public int getBitsPerEntry() {
+    return this.bitsPerEntry;
+  }
+
+
+  public int getSize() {
+    return this.size;
+  }
+
+  @Override
+  public int get(int index) {
+    if (index < 0 || index > this.size - 1) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    int bitIndex = index * this.bitsPerEntry;
+    int startIndex = bitIndex / 64;
+    int endIndex = ((index + 1) * this.bitsPerEntry - 1) / 64;
+    int startBitSubIndex = bitIndex % 64;
+    if (startIndex == endIndex) {
+      return (int) (this.data[startIndex] >>> startBitSubIndex & this.maxEntryValue);
+    } else {
+      int endBitSubIndex = 64 - startBitSubIndex;
+      return (int) (
+          (this.data[startIndex] >>> startBitSubIndex | this.data[endIndex] << endBitSubIndex)
+              & this.maxEntryValue);
+    }
+  }
+
+  @Override
+  public void set(int index, int value) {
+    if (index < 0 || index > this.size - 1) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    if (value < 0 || value > this.maxEntryValue) {
+      throw new IllegalArgumentException("Value cannot be outside of accepted range.");
+    }
+
+    int bitIndex = index * this.bitsPerEntry;
+    int startIndex = bitIndex / 64;
+    int endIndex = ((index + 1) * this.bitsPerEntry - 1) / 64;
+    int startBitSubIndex = bitIndex % 64;
+    this.data[startIndex] = this.data[startIndex] & ~(this.maxEntryValue << startBitSubIndex)
+        | ((long) value & this.maxEntryValue) << startBitSubIndex;
+    if (startIndex != endIndex) {
+      int endBitSubIndex = 64 - startBitSubIndex;
+      this.data[endIndex] = this.data[endIndex] >>> endBitSubIndex << endBitSubIndex
+          | ((long) value & this.maxEntryValue) >> endBitSubIndex;
+    }
+  }
+
+  @Override
+  public int getDataLength() {
+    return ProtocolUtils.varIntBytes(data.length) + data.length * 8;
+  }
+
+  @Override
+  public void write(ByteBuf buf, ProtocolVersion version) {
+    ProtocolUtils.writeVarInt(buf, data.length);
+    for (long l : data) {
+      buf.writeLong(l);
+    }
+  }
+
+  @Override
+  public CompactStorage copy() {
+    return new BitStorage19(bitsPerEntry, Arrays.copyOf(data, data.length));
+  }
+
+  @Override
+  public long[] getData() {
+    return data;
+  }
+
+  private static int roundToNearest(int value, int roundTo) {
+    if (roundTo == 0) {
+      return 0;
+    } else if (value == 0) {
+      return roundTo;
+    } else {
+      if (value < 0) {
+        roundTo *= -1;
+      }
+
+      int remainder = value % roundTo;
+      return remainder != 0 ? value + roundTo - remainder : value;
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/NibbleArray3d.java b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/NibbleArray3d.java
new file mode 100644
index 00000000..eb60d51a
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/protocol/util/mcprotocollib/NibbleArray3d.java
@@ -0,0 +1,85 @@
+/*
+ * This file is part of MCProtocolLib, licensed under the MIT License (MIT).
+ *
+ * Copyright (c) Steveice10 <https://github.com/Steveice10/MCProtocolLib>
+ * Copyright (c) contributors
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+package ru.leymooo.botfilter.protocol.util.mcprotocollib;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.util.Arrays;
+
+@SuppressFBWarnings({"EI_EXPOSE_REP2", "EI_EXPOSE_REP"})
+public class NibbleArray3d {
+
+  private byte[] data;
+
+  public NibbleArray3d(int size) {
+    this.data = new byte[size >> 1];
+  }
+
+  public NibbleArray3d(int size, int defValue) {
+    this.data = new byte[size >> 1];
+    fill(defValue);
+  }
+
+  public NibbleArray3d(byte[] array) {
+    this.data = array;
+  }
+
+  public byte[] getData() {
+    return this.data;
+  }
+
+  public int get(int x, int y, int z) {
+    int key = y << 8 | z << 4 | x;
+    int index = key >> 1;
+    int part = key & 1;
+    return part == 0 ? this.data[index] & 15 : this.data[index] >> 4 & 15;
+  }
+
+  public void set(int x, int y, int z, int val) {
+    int key = y << 8 | z << 4 | x;
+    set(key, val);
+  }
+
+  public void set(int key, int val) {
+    int index = key >> 1;
+    int part = key & 1;
+    if (part == 0) {
+      this.data[index] = (byte) (this.data[index] & 240 | val & 15);
+    } else {
+      this.data[index] = (byte) (this.data[index] & 15 | (val & 15) << 4);
+    }
+  }
+
+  public void fill(int val) {
+    for (int index = 0; index < this.data.length << 1; index++) {
+      set(index, val);
+    }
+  }
+
+  public NibbleArray3d copy() {
+    return new NibbleArray3d(Arrays.copyOf(data, data.length));
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/BotFilterSessionHandler.java b/proxy/src/main/java/ru/leymooo/botfilter/server/BotFilterSessionHandler.java
new file mode 100644
index 00000000..ed366429
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/BotFilterSessionHandler.java
@@ -0,0 +1,70 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server;
+
+
+import com.velocitypowered.proxy.connection.MinecraftSessionHandler;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
+import com.velocitypowered.proxy.connection.client.LoginSessionHandler;
+import java.util.Objects;
+import lombok.Data;
+
+@Data
+public class BotFilterSessionHandler implements MinecraftSessionHandler {
+
+
+  private final ConnectedPlayer player;
+  private final LoginSessionHandler originalHandler;
+  private final VirtualServer virtualServer;
+
+  @Override
+  public void disconnected() {
+    virtualServer.disconnected(this);
+  }
+
+  @Override
+  public void deactivated() {
+    virtualServer.disconnected(this);
+  }
+
+  private void finishCheck() {
+    player.getConnection().setSessionHandler(originalHandler);
+    originalHandler.initialize(player);
+    //fakeServer.getBotFilter().restoreOriginalHandlers(user);
+    //afterCheck.run();
+  }
+
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    BotFilterSessionHandler that = (BotFilterSessionHandler) o;
+    return player.getUsername().equals(that.player.getUsername());
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(player.getUsername());
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/ServerPackets.java b/proxy/src/main/java/ru/leymooo/botfilter/server/ServerPackets.java
new file mode 100644
index 00000000..67ab35dd
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/ServerPackets.java
@@ -0,0 +1,203 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server;
+
+import com.google.common.collect.ImmutableList;
+import com.velocitypowered.api.network.ProtocolVersion;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import com.velocitypowered.proxy.protocol.packet.Disconnect;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import lombok.Getter;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import ru.leymooo.botfilter.config.BotFilterConfiguration;
+import ru.leymooo.botfilter.protocol.cache.MultiplePreparedPackets;
+import ru.leymooo.botfilter.protocol.cache.PacketCompressor;
+import ru.leymooo.botfilter.protocol.cache.PreparedPacket;
+import ru.leymooo.botfilter.protocol.data.registry.Biome;
+import ru.leymooo.botfilter.protocol.data.registry.Dimension;
+import ru.leymooo.botfilter.protocol.data.registry.DimensionRegistry;
+import ru.leymooo.botfilter.protocol.packet.JoinGame;
+import ru.leymooo.botfilter.protocol.packet.PlayerPositionAndLook;
+import ru.leymooo.botfilter.protocol.packet.UpdateViewPosition;
+import ru.leymooo.botfilter.protocol.packet.world.ChunkData;
+import ru.leymooo.botfilter.protocol.packet.world.UpdateLight;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.VirtualWorld;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk;
+
+@Getter
+public class ServerPackets {
+
+  private final PacketCompressor packetCompressor;
+  private final VirtualServer virtualServer;
+  private VirtualWorld virtualWorld;
+  //JoinGame +  Chunks + Light + PlayerPosAndLook
+  private MultiplePreparedPackets spawnPackets;
+  private PreparedPacket<Disconnect> alreadyConnected;
+
+
+  public ServerPackets(PacketCompressor packetCompressor,
+      VirtualServer virtualServer) {
+    this.packetCompressor = packetCompressor;
+    this.virtualServer = virtualServer;
+  }
+
+
+  public void createPackets(BotFilterConfiguration configuration) {
+    releaseAll();
+    this.virtualWorld = new VirtualWorld(Dimension.OVERWORLD,
+        new DimensionInfo(Dimension.OVERWORLD.getKey(), Dimension.OVERWORLD.getKey(), true, false));
+    virtualWorld.setSkyLight(0, 60, 0,
+        (byte) 1); //1.7 workaround //TODO: Maybe broken with new light system realiztion
+
+    /*
+    for (int x = 0; x < 16; x++) {
+      for (int z = 0; z < 16; z++) {
+        virtualWorld.setBlock(x, 40, z, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(x, 60, z, SimpleBlock.GRANITE);
+      }
+    }
+    for (int x = 1; x < 15; x++) {
+      for (int z = 1; z < 15; z++) {
+        if (x % 3 == 0 && z % 3 == 0) {
+          virtualWorld.setBlock(x, 40, z, SimpleBlock.BARRIER);
+          virtualWorld.setBlockLight(x, 41, z, (byte) 15);
+        }
+      }
+    }
+    for (int x = 0; x < 16; x++) {
+      for (int y = 40; y <= 60; y++) {
+        virtualWorld.setBlock(x, y, 0, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(0, y, x, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(x, y, 15, SimpleBlock.GRANITE);
+        virtualWorld.setBlock(15, y, x, SimpleBlock.GRANITE);
+      }
+    }
+     */
+
+    List<PreparedPacket> preparedPackets = new ArrayList<>();
+    preparedPackets.add(createJoinGamePacket());
+    preparedPackets.addAll(createChunksPackets());
+    preparedPackets.addAll(createUpdateLightPackets());
+    preparedPackets.add(createPlayerPosAndLookPacket());
+    spawnPackets = new MultiplePreparedPackets(preparedPackets.toArray(new PreparedPacket[0]));
+    alreadyConnected = createDisconnectPacket("&cAlready connected", StateRegistry.LOGIN);
+    virtualWorld = null;
+  }
+
+  //TODO use Dimensions ids for < 1.16 version
+  private PreparedPacket<JoinGame> createJoinGamePacket() {
+    DimensionRegistry dimensionRegistry = new DimensionRegistry();
+    dimensionRegistry.addDimension(
+        Dimension.OVERWORLD, ImmutableList.of(Biome.PLAINTS, Biome.SWAMP, Biome.SWAMP_HILLS));
+    dimensionRegistry.setActiveDimension(Dimension.OVERWORLD);
+    dimensionRegistry.setActiveDimensionInfo(
+        new DimensionInfo("minecraft:overworld", "minecraft:overworld", false, false));
+    PreparedPacket<JoinGame> joinGame = new PreparedPacket<>();
+    joinGame.prepare(JoinGame.builder().entityId(0).gamemode((short) 1).dimension(0).
+        partialHashedSeed(1).difficulty((short) 0).maxPlayers(1).levelType("flat").viewDistance(4)
+        .reducedDebugInfo(false).showRespawnScreen(true).hardcore(false)
+        .dimensionRegistry(dimensionRegistry).build());
+
+    return processCompression(joinGame);
+  }
+
+  private PreparedPacket<PlayerPositionAndLook> createPlayerPosAndLookPacket() {
+    PreparedPacket<PlayerPositionAndLook> playerPosAndLook = new PreparedPacket<>();
+    playerPosAndLook.prepare(new PlayerPositionAndLook(6, 60, 6, 0f, 0f, -133, false, true));
+    return processCompression(playerPosAndLook);
+  }
+
+  private List<PreparedPacket<ChunkData>> createChunksPackets() {
+    List<PreparedPacket<ChunkData>> packets = new ArrayList<>();
+    for (SimpleChunk chunk : virtualWorld.getChunks()) {
+      packets.add(createChunkDataPacket(chunk));
+    }
+    return packets;
+  }
+
+  private PreparedPacket<ChunkData> createChunkDataPacket(SimpleChunk chunk) {
+    PreparedPacket<ChunkData> chunkPacket = new PreparedPacket<>();
+    chunkPacket.prepare(new ChunkData(chunk.getFullChunkSnapshot(),
+        chunk.getWorld().getDimension().isHasSkylight()));
+    return processCompression(chunkPacket);
+  }
+
+  private List<PreparedPacket<UpdateLight>> createUpdateLightPackets() {
+    List<PreparedPacket<UpdateLight>> packets = new ArrayList<>();
+    for (SimpleChunk chunk : virtualWorld.getChunks()) {
+      packets.add(createUpdateLightPacket(chunk));
+    }
+    return packets;
+  }
+
+  private PreparedPacket<UpdateLight> createUpdateLightPacket(SimpleChunk chunk) {
+    PreparedPacket<UpdateLight> lightPacket = new PreparedPacket<>();
+    lightPacket
+        .prepare(new UpdateLight(chunk.getFullChunkSnapshot()), ProtocolVersion.MINECRAFT_1_14);
+    return processCompression(lightPacket);
+  }
+
+  private PreparedPacket<UpdateViewPosition> createUpdateViewPositionPacket(SimpleChunk chunk) {
+    PreparedPacket<UpdateViewPosition> update = new PreparedPacket<>();
+    update.prepare(new UpdateViewPosition(chunk.getX(), chunk.getZ()),
+        ProtocolVersion.MINECRAFT_1_17);
+    return processCompression(update);
+  }
+
+  private PreparedPacket<Disconnect> createDisconnectPacket(String message,
+      StateRegistry protocol) {
+    Component component = LegacyComponentSerializer.legacyAmpersand().deserialize(message);
+    PreparedPacket<Disconnect> disconnect = new PreparedPacket<>();
+    disconnect.prepare(Disconnect.create(component, ProtocolVersion.MINECRAFT_1_7_2),
+        ProtocolVersion.MINECRAFT_1_7_2, ProtocolVersion.MINECRAFT_1_15_2, protocol);
+    disconnect.prepare(Disconnect.create(component, ProtocolVersion.MINECRAFT_1_16),
+        ProtocolVersion.MINECRAFT_1_16, protocol);
+    if (protocol == StateRegistry.LOGIN) {
+      disconnect.finish();
+      return disconnect;
+    }
+    return processCompression(disconnect);
+  }
+
+  private <T extends PreparedPacket<?>> T processCompression(T preparedPacket) {
+    if (packetCompressor.isCompressionEnabled()) {
+      preparedPacket.processCompress(packetCompressor);
+    }
+    preparedPacket.finish();
+    return preparedPacket;
+  }
+
+
+  public void releaseAll() {
+    for (PreparedPacket packet : Arrays.asList(alreadyConnected)) {
+      if (packet != null) {
+        packet.releaseBuffers();
+      }
+    }
+    if (spawnPackets != null) {
+      spawnPackets.release();
+    }
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/VirtualServer.java b/proxy/src/main/java/ru/leymooo/botfilter/server/VirtualServer.java
new file mode 100644
index 00000000..686c02fb
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/VirtualServer.java
@@ -0,0 +1,70 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server;
+
+import com.velocitypowered.proxy.connection.MinecraftConnection;
+import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
+import com.velocitypowered.proxy.protocol.StateRegistry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import lombok.Getter;
+import ru.leymooo.botfilter.BotFilter;
+import ru.leymooo.botfilter.protocol.cache.PacketCompressor;
+
+public class VirtualServer {
+
+  @Getter private final BotFilter botFilter;
+  private final ConcurrentMap<String, BotFilterSessionHandler> activeConnections = new ConcurrentHashMap<>();
+  private final ServerPackets packets;
+
+  public VirtualServer(BotFilter botFilter) {
+    this.botFilter = botFilter;
+    this.packets = new ServerPackets(
+        new PacketCompressor(botFilter.getVelocityServer()::getConfiguration), this);
+  }
+
+
+  public void reload() {
+    for (BotFilterSessionHandler session : activeConnections.values()) {
+      session.getPlayer().getConnection().close();
+    }
+    packets.createPackets(botFilter.getBotFilterConfiguration());
+  }
+
+
+  public void spawnPlayer(BotFilterSessionHandler user) {
+    String username = user.getPlayer().getUsername().toLowerCase();
+    ConnectedPlayer player = user.getPlayer();
+    MinecraftConnection connection = player.getConnection();
+    if (activeConnections.putIfAbsent(username, user) != null) {
+      connection.closeWith(packets.getAlreadyConnected());
+      //user.closeWith(preparedPackets.getAlreadyConnected());
+      return;
+    }
+    user.getOriginalHandler().completeLoginProtocol(player, false);
+    connection.setState(StateRegistry.BotFilter);
+    packets.getSpawnPackets().write(connection, player.isOnlineMode());
+    connection.flush();
+  }
+
+  public void disconnected(BotFilterSessionHandler botFilterConnection) {
+    activeConnections.remove(botFilterConnection.getPlayer().getUsername().toLowerCase());
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/world/SimpleBlock.java b/proxy/src/main/java/ru/leymooo/botfilter/server/world/SimpleBlock.java
new file mode 100644
index 00000000..8786d6a2
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/world/SimpleBlock.java
@@ -0,0 +1,250 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server.world;
+
+import static ru.leymooo.botfilter.server.world.SimpleBlock.BlockInfo.fallback;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.BlockInfo.info;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_13;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_13_1;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_14;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_16;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_16_2;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_17;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_7;
+import static ru.leymooo.botfilter.server.world.SimpleBlock.Version.MINECRAFT_1_8;
+
+import com.velocitypowered.api.network.ProtocolVersion;
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import lombok.NonNull;
+import org.jetbrains.annotations.NotNull;
+
+public class SimpleBlock {
+
+  public static final SimpleBlock AIR = air(
+      info(MINECRAFT_1_7, 0)
+  );
+  public static final SimpleBlock STONE = solid(
+      info(MINECRAFT_1_7, 1)
+  );
+  public static final SimpleBlock GRANITE = solid(
+      fallback(MINECRAFT_1_7, STONE),
+      info(MINECRAFT_1_8, 1, 1),
+      info(MINECRAFT_1_13, 2)
+  );
+  public static final SimpleBlock GLASS = solid(
+      info(MINECRAFT_1_7, 20),
+      info(MINECRAFT_1_13, 230),
+      info(MINECRAFT_1_16, 231),
+      info(MINECRAFT_1_17, 262)
+  );
+  public static final SimpleBlock TORCH = nonSolid(false,
+      info(MINECRAFT_1_7, 50, 14),
+      info(MINECRAFT_1_13, 1130),
+      info(MINECRAFT_1_13_1, 1131),
+      info(MINECRAFT_1_14, 1134),
+      info(MINECRAFT_1_16, 1435),
+      info(MINECRAFT_1_17, 1491)
+  );
+  public static final SimpleBlock BARRIER = solid(
+      fallback(MINECRAFT_1_7, GLASS),
+      info(MINECRAFT_1_8, 166),
+      info(MINECRAFT_1_13, 6493),
+      info(MINECRAFT_1_13_1, 6494),
+      info(MINECRAFT_1_14, 7000),
+      info(MINECRAFT_1_16, 7536),
+      info(MINECRAFT_1_16_2, 7540),
+      info(MINECRAFT_1_17, 7754)
+  );
+
+  private final Map<Version, BlockInfo> blockInfos = new EnumMap<>(Version.class);
+  private final boolean solid;
+  private final boolean air;
+  private final boolean motionBlocking; //1.14+
+
+  public SimpleBlock(boolean solid, boolean air, boolean motionBlocking, BlockInfo... blockInfos) {
+    this.motionBlocking = motionBlocking;
+    for (BlockInfo info : blockInfos) {
+      for (Version version : EnumSet.range(info.version, MINECRAFT_1_17)) {
+        this.blockInfos.put(version, info);
+      }
+    }
+    this.air = air;
+    this.solid = solid;
+  }
+
+  public short getId(Version version) {
+    return blockInfos.get(version).getId();
+  }
+
+  public byte getData(Version version) {
+    return blockInfos.get(version).getData();
+  }
+
+  public boolean isSolid() {
+    return solid;
+  }
+
+  public boolean isAir() {
+    return air;
+  }
+
+  public boolean isMotionBlocking() {
+    return motionBlocking;
+  }
+
+  public static @NotNull SimpleBlock solid(BlockInfo... infos) {
+    return solid(true, infos);
+  }
+
+  public static @NotNull SimpleBlock solid(boolean motionBlocking, BlockInfo... infos) {
+    return new SimpleBlock(true, false, motionBlocking, infos);
+  }
+
+
+  public static @NotNull SimpleBlock nonSolid(BlockInfo... infos) {
+    return nonSolid(true, infos);
+  }
+
+  public static @NotNull SimpleBlock nonSolid(boolean motionBlocking, BlockInfo... infos) {
+    return new SimpleBlock(false, false, motionBlocking, infos);
+  }
+
+  public static @NotNull SimpleBlock air(BlockInfo... infos) {
+    return new SimpleBlock(false, true, false, infos);
+  }
+
+  public enum Version {
+    MINECRAFT_1_7(ProtocolVersion.MINECRAFT_1_7_2, ProtocolVersion.MINECRAFT_1_7_6),
+    MINECRAFT_1_8(ProtocolVersion.MINECRAFT_1_8),
+    MINECRAFT_1_9(EnumSet.range(ProtocolVersion.MINECRAFT_1_9, ProtocolVersion.MINECRAFT_1_9_4)),
+    MINECRAFT_1_10(ProtocolVersion.MINECRAFT_1_10),
+    MINECRAFT_1_11(ProtocolVersion.MINECRAFT_1_11, ProtocolVersion.MINECRAFT_1_11_1),
+    MINECRAFT_1_12(EnumSet.range(ProtocolVersion.MINECRAFT_1_12, ProtocolVersion.MINECRAFT_1_12_2)),
+    MINECRAFT_1_13(ProtocolVersion.MINECRAFT_1_13),
+    MINECRAFT_1_13_1(ProtocolVersion.MINECRAFT_1_13_1, ProtocolVersion.MINECRAFT_1_13_2),
+    MINECRAFT_1_14(EnumSet.range(ProtocolVersion.MINECRAFT_1_14, ProtocolVersion.MINECRAFT_1_14_4)),
+    MINECRAFT_1_15(EnumSet.range(ProtocolVersion.MINECRAFT_1_15, ProtocolVersion.MINECRAFT_1_15_2)),
+    MINECRAFT_1_16(ProtocolVersion.MINECRAFT_1_16, ProtocolVersion.MINECRAFT_1_16_1),
+    MINECRAFT_1_16_2(ProtocolVersion.MINECRAFT_1_16_2, ProtocolVersion.MINECRAFT_1_16_3),
+    MINECRAFT_1_16_4(ProtocolVersion.MINECRAFT_1_16_4),
+    MINECRAFT_1_17(ProtocolVersion.MINECRAFT_1_17);
+
+    private static EnumMap<ProtocolVersion, Version> mcVersionToBlockVersions = new EnumMap<>(
+        ProtocolVersion.class);
+
+
+    static {
+      for (Version version : Version.values()) {
+        for (ProtocolVersion protocolVersion : version.versions) {
+          mcVersionToBlockVersions.put(protocolVersion, version);
+        }
+      }
+    }
+
+    private Set<ProtocolVersion> versions;
+
+    Version(ProtocolVersion... versions) {
+      this.versions = EnumSet.copyOf(Arrays.asList(versions));
+    }
+
+    Version(Set<ProtocolVersion> versions) {
+      this.versions = versions;
+    }
+
+    public boolean isBefore(Version other) {
+      return this.compareTo(other) < 0;
+    }
+
+    public boolean isBeforeOrEq(Version other) {
+      return this.compareTo(other) <= 0;
+    }
+
+    public boolean isAfter(Version other) {
+      return this.compareTo(other) > 0;
+    }
+
+    public boolean isAfterOrEq(Version other) {
+      return this.compareTo(other) >= 0;
+    }
+
+    public Set<ProtocolVersion> getVersions() {
+      return versions;
+    }
+
+    public static Version map(ProtocolVersion protocolVersion) {
+      return mcVersionToBlockVersions.get(protocolVersion);
+    }
+
+  }
+
+  public static class BlockInfo {
+
+    @NonNull
+    @NotNull
+    private final Version version;
+    private final short id;
+    private final byte data;
+    private final BlockInfo fallback;
+
+    public BlockInfo(Version version, short id, byte data) {
+      this(version, id, data, null);
+    }
+
+    public BlockInfo(Version version, @NonNull BlockInfo fallback) {
+      this(version, (short) 0, (byte) 0, fallback);
+    }
+
+    private BlockInfo(@NonNull Version version, short id, byte data, BlockInfo fallback) {
+      this.version = version;
+      this.id = id;
+      this.data = data;
+      this.fallback = fallback;
+    }
+
+    public Version getVersion() {
+      return version;
+    }
+
+    public short getId() {
+      return fallback == null ? id : fallback.getId();
+    }
+
+    public byte getData() {
+      return fallback == null ? data : fallback.getData();
+    }
+
+    public static BlockInfo info(Version version, int id, int meta) {
+      return new BlockInfo(version, (short) id, (byte) meta);
+    }
+
+    public static BlockInfo info(Version version, int id) {
+      return info(version, id, 0);
+    }
+
+    public static BlockInfo fallback(Version version, SimpleBlock fallback) {
+      return new BlockInfo(version, fallback.blockInfos.get(version));
+    }
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/world/VirtualWorld.java b/proxy/src/main/java/ru/leymooo/botfilter/server/world/VirtualWorld.java
new file mode 100644
index 00000000..c32a0db0
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/world/VirtualWorld.java
@@ -0,0 +1,142 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server.world;
+
+import com.google.common.collect.ImmutableList;
+import com.velocitypowered.proxy.connection.registry.DimensionInfo;
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import lombok.Getter;
+import lombok.NonNull;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import ru.leymooo.botfilter.protocol.data.registry.Biome;
+import ru.leymooo.botfilter.protocol.data.registry.Dimension;
+import ru.leymooo.botfilter.server.world.chunk.SimpleChunk;
+
+public class VirtualWorld {
+
+  @NonNull
+  @Getter
+  private final Dimension dimension;
+  @NonNull
+  @Getter
+  private final DimensionInfo dimensionInfo;
+  private final Map<Long, SimpleChunk> chunks = new HashMap<>();
+
+  public VirtualWorld(@NonNull Dimension dimension, @NonNull DimensionInfo dimensionInfo) {
+    this.dimension = dimension;
+    this.dimensionInfo = dimensionInfo;
+    getChunkOrNew(0, 0);
+  }
+
+  public void setBlock(int x, int y, int z, @Nullable SimpleBlock block) {
+    getChunkOrNew(x, z).setBlock(getChunkCoordinate(x), y, getChunkCoordinate(z), block);
+  }
+
+  @SuppressFBWarnings("NP_NONNULL_RETURN_VIOLATION")
+  @NotNull
+  public SimpleBlock getBlock(int x, int y, int z) {
+    return chunkAction(x, z, (c) -> c.getBlock(getChunkCoordinate(x), y, getChunkCoordinate(z)),
+        () -> SimpleBlock.AIR);
+  }
+
+  public void setBiome2d(int x, int z, @NonNull Biome biome) {
+    getChunkOrNew(x, z).setBiome2d(getChunkCoordinate(x), getChunkCoordinate(z), biome);
+  }
+
+  public void setBiome3d(int x, int y, int z, @NonNull Biome biome) {
+    getChunkOrNew(x, z).setBiome3d(getChunkCoordinate(x), y, getChunkCoordinate(z), biome);
+  }
+
+  public Biome getBiome(int x, int y, int z) {
+    return chunkAction(x, z, (c) -> c.getBiome(x, y, z), () -> Biome.PLAINTS);
+  }
+
+  public byte getBlockLight(int x, int y, int z) {
+    return chunkAction(x, z,
+        (c) -> c.getBlockLight(getChunkCoordinate(x), y, getChunkCoordinate(z)), () -> (byte) 0);
+  }
+
+  public void setBlockLight(int x, int y, int z, byte light) {
+    getChunkOrNew(x, z).setBlockLight(getChunkCoordinate(x), y, getChunkCoordinate(z), light);
+  }
+
+  public byte getSkyLight(int x, int y, int z) {
+    return chunkAction(x, z,
+        (c) -> c.getSkyLight(getChunkCoordinate(x), y, getChunkCoordinate(z)), () -> (byte) 0);
+  }
+
+
+  public void setSkyLight(int x, int y, int z, byte light) {
+    getChunkOrNew(x, z).setSkyLight(getChunkCoordinate(x), y, getChunkCoordinate(z), light);
+  }
+
+  public List<SimpleChunk> getChunks() {
+    return ImmutableList.copyOf(chunks.values());
+  }
+
+  private <T> T chunkAction(int x, int z, Function<SimpleChunk, T> function, Supplier<T> ifNull) {
+    SimpleChunk chunk = getChunk(x, z);
+    if (chunk == null) {
+      return ifNull.get();
+    }
+    return function.apply(chunk);
+  }
+
+  @Nullable
+  public SimpleChunk getChunk(int x, int z) {
+    return chunks.get(getChunkIndex(getChunkXZ(x), getChunkXZ(z)));
+  }
+
+  public SimpleChunk getChunkOrNew(int x, int z) {
+    x = getChunkXZ(x);
+    z = getChunkXZ(z);
+    long index = getChunkIndex(x, z);
+    SimpleChunk simpleChunk = chunks.get(index);
+    if (simpleChunk == null) {
+      chunks.put(index, simpleChunk = new SimpleChunk(this, x, z));
+    }
+    return simpleChunk;
+  }
+
+
+  private static long getChunkIndex(int x, int z) {
+    return (((long) x) << 32) | (z & 0xffffffffL);
+  }
+
+
+  private static int getChunkXZ(int xz) {
+    return Math.floorDiv(xz, 16);
+  }
+
+  private static int getChunkCoordinate(int xz) {
+    xz %= 16;
+    if (xz < 0) {
+      xz += 16;
+    }
+    return xz;
+  }
+
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/ChunkSnapshot.java b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/ChunkSnapshot.java
new file mode 100644
index 00000000..dc95dc60
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/ChunkSnapshot.java
@@ -0,0 +1,41 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server.world.chunk;
+
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+import ru.leymooo.botfilter.protocol.data.registry.Biome;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+
+@RequiredArgsConstructor
+@Getter
+public class ChunkSnapshot {
+
+  private final int x;
+  private final int z;
+  private final boolean fullChunk;
+  private final SimpleSection[] sections;
+  private final LightSection[] light;
+  private final Biome[] biomes;
+
+  public SimpleBlock getBlock(int x, int y, int z) {
+    SimpleSection section = sections[y / 16];
+    return section == null ? SimpleBlock.AIR : section.getBlockAt(x, y % 16, z);
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/LightSection.java b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/LightSection.java
new file mode 100644
index 00000000..5d1b8f2e
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/LightSection.java
@@ -0,0 +1,94 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server.world.chunk;
+
+import static ru.leymooo.botfilter.server.world.chunk.SimpleChunk.MAX_BLOCKS_PER_SECTION;
+
+import com.google.common.base.Preconditions;
+import lombok.AccessLevel;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.NoArgsConstructor;
+import ru.leymooo.botfilter.protocol.util.mcprotocollib.NibbleArray3d;
+
+@AllArgsConstructor(access = AccessLevel.PRIVATE)
+@NoArgsConstructor
+public class LightSection {
+
+
+
+  public static NibbleArray3d NO_LIGHT = new NibbleArray3d(MAX_BLOCKS_PER_SECTION);
+  public static NibbleArray3d ALL_LIGHT = new NibbleArray3d(MAX_BLOCKS_PER_SECTION, 15);
+  public static final LightSection DEFAULT = new LightSection();
+
+  @Getter
+  private NibbleArray3d blockLight = NO_LIGHT;
+  @Getter
+  private NibbleArray3d skyLight = ALL_LIGHT;
+  @Getter
+  private long lastUpdate = System.nanoTime();
+
+  public byte getBlockLight(int x, int y, int z) {
+    checkIndexes(x, y, z);
+    return (byte) blockLight.get(x, y, z);
+  }
+
+
+  public byte getSkyLight(int x, int y, int z) {
+    checkIndexes(x, y, z);
+    return (byte) skyLight.get(x, y, z);
+  }
+
+
+  public void setBlockLight(int x, int y, int z, byte light) {
+    checkIndexes(x, y, z);
+    Preconditions.checkArgument(light >= 0 && light <= 15, "light should be between 0 and 15");
+    if (blockLight == NO_LIGHT && light != 0) {
+      blockLight = new NibbleArray3d(MAX_BLOCKS_PER_SECTION);
+    }
+    blockLight.set(x, y, z, light);
+    lastUpdate = System.nanoTime();
+  }
+
+  public void setSkyLight(int x, int y, int z, byte light) {
+    checkIndexes(x, y, z);
+    Preconditions.checkArgument(light >= 0 && light <= 15, "light should be between 0 and 15");
+    if (skyLight == ALL_LIGHT && light != 15) {
+      skyLight = new NibbleArray3d(MAX_BLOCKS_PER_SECTION);
+    }
+    skyLight.set(x, y, z, light);
+    lastUpdate = System.nanoTime();
+  }
+
+  private void checkIndexes(int x, int y, int z) {
+    Preconditions.checkArgument(checkIndex(x), "x should be between 0 and 15");
+    Preconditions.checkArgument(checkIndex(y), "y should be between 0 and 15");
+    Preconditions.checkArgument(checkIndex(z), "z should be between 0 and 15");
+  }
+
+  private boolean checkIndex(int i) {
+    return i >= 0 && i <= 15;
+  }
+
+  public LightSection copy() {
+    NibbleArray3d skyLight = this.skyLight == ALL_LIGHT ? ALL_LIGHT : this.skyLight.copy();
+    NibbleArray3d blockLight = this.blockLight == NO_LIGHT ? NO_LIGHT : this.blockLight.copy();
+    return new LightSection(blockLight, skyLight, lastUpdate);
+  }
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/SimpleChunk.java b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/SimpleChunk.java
new file mode 100644
index 00000000..3c137a32
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/SimpleChunk.java
@@ -0,0 +1,157 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server.world.chunk;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import java.util.Arrays;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import lombok.Getter;
+import lombok.NonNull;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import ru.leymooo.botfilter.protocol.data.registry.Biome;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.VirtualWorld;
+
+@SuppressFBWarnings("NP_NONNULL_RETURN_VIOLATION")
+public class SimpleChunk {
+
+  public static final int MAX_BLOCKS_PER_SECTION = 16 * 16 * 16;
+
+  @Getter private final VirtualWorld world;
+  @Getter private final int x;
+  @Getter private final int z;
+  private final SimpleSection[] sections = new SimpleSection[16];
+  private final LightSection[] light = new LightSection[18];
+  private final Biome[] biomes = new Biome[1024];
+
+  public SimpleChunk(VirtualWorld world, int x, int z) {
+    this.world = world;
+    this.x = x;
+    this.z = z;
+    Arrays.fill(biomes, Biome.PLAINTS);
+    //Arrays.fill(light, LightSection.DEFAULT);
+  }
+
+  public void setBlock(int x, int y, int z, @Nullable SimpleBlock block) {
+    SimpleSection section = getSection(y);
+    section.setBlockAt(x, y % 16, z, block);
+  }
+
+  @NotNull
+  public SimpleBlock getBlock(int x, int y, int z) {
+    return sectionAction(y, (s) -> s.getBlockAt(x, y % 16, z), () -> SimpleBlock.AIR);
+  }
+
+  @NotNull
+  public Biome getBiome(int x, int y, int z) {
+    return biomes[getBiomeIndex(x, y, z)];
+  }
+
+
+  public void setBiome2d(int x, int z, @NonNull Biome biome) {
+    for (int y = 0; y < 256; y += 4) {
+      setBiome3d(x, y, z, biome);
+    }
+  }
+
+
+  public void setBiome3d(int x, int y, int z, @NonNull Biome biome) {
+    this.biomes[getBiomeIndex(x, y, z)] = biome;
+  }
+
+  public byte getBlockLight(int x, int y, int z) {
+    return getLightSection(y, false).getBlockLight(x, y % 16, z);
+  }
+
+  public void setBlockLight(int x, int y, int z, byte light) {
+    getLightSection(y, true).setBlockLight(x, y % 16, z, light);
+  }
+
+  public byte getSkyLight(int x, int y, int z) {
+    return getLightSection(y, false).getSkyLight(x, y % 16, z);
+  }
+
+  public void setSkyLight(int x, int y, int z, byte light) {
+    getLightSection(y, true).setSkyLight(x, y % 16, z, light);
+  }
+
+  public ChunkSnapshot getFullChunkSnapshot() {
+    return createSnapshot(true, 0);
+  }
+
+  public ChunkSnapshot getPartialChunkSnapshot(long previousUpdate) {
+    return createSnapshot(false, previousUpdate);
+  }
+
+  private ChunkSnapshot createSnapshot(boolean full, long previousUpdate) {
+    SimpleSection[] sectionsSnapshot = new SimpleSection[sections.length];
+    for (int i = 0; i < sections.length; i++) {
+      if (sections[i] != null && sections[i].getLastUpdate() > previousUpdate) {
+        sectionsSnapshot[i] = sections[i].getSnapshot();
+      }
+    }
+    LightSection[] lightSnapshot = new LightSection[18];
+    for (int i = 0; i < light.length; i++) {
+      if (light[i] == null) {
+        lightSnapshot[i] = LightSection.DEFAULT;
+      } else if (light[i].getLastUpdate() > previousUpdate) {
+        lightSnapshot[i] = light[i].copy();
+      }
+    }
+    return new ChunkSnapshot(x, z, full, sectionsSnapshot, lightSnapshot,
+        Arrays.copyOf(biomes, biomes.length));
+  }
+
+  private SimpleSection getSection(int y) {
+    int s = getSectionIndex(y);
+    SimpleSection section = sections[s];
+    if (section == null) {
+      sections[s] = (section = new SimpleSection());
+    }
+    return section;
+  }
+
+  private <T> T sectionAction(int y, Function<SimpleSection, T> function, Supplier<T> ifNull) {
+    SimpleSection section = sections[getSectionIndex(y)];
+    if (section == null) {
+      return ifNull.get();
+    }
+    return function.apply(section);
+  }
+
+  private LightSection getLightSection(int y, boolean create) {
+    int index = y < 0 ? 0 : getSectionIndex(y) + 1;
+    LightSection result = light[index];
+    if (create && result == null) {
+      light[index] = result = new LightSection();
+    }
+    return result == null ? LightSection.DEFAULT : result;
+  }
+
+  private static int getSectionIndex(int y) {
+    return y / 16;
+  }
+
+  public static int getBiomeIndex(int x, int y, int z) {
+    return ((y >> 2) & 63) << 4 | ((z >> 2) & 3) << 2 | ((x >> 2) & 3);
+  }
+
+}
diff --git a/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/SimpleSection.java b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/SimpleSection.java
new file mode 100644
index 00000000..1f38b027
--- /dev/null
+++ b/proxy/src/main/java/ru/leymooo/botfilter/server/world/chunk/SimpleSection.java
@@ -0,0 +1,72 @@
+/*
+ * Velocity-BotFilter
+ * Copyright (C) 2021  Vjat≈°eslav Maspanov <Leymooo>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.leymooo.botfilter.server.world.chunk;
+
+import com.google.common.base.Preconditions;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import ru.leymooo.botfilter.protocol.data.storage.BlockStorage;
+import ru.leymooo.botfilter.protocol.data.storage.BlockStorage19;
+import ru.leymooo.botfilter.server.world.SimpleBlock;
+import ru.leymooo.botfilter.server.world.SimpleBlock.Version;
+
+@RequiredArgsConstructor
+@AllArgsConstructor()
+public class SimpleSection {
+
+  private final BlockStorage blocks;
+  @Getter
+  private long lastUpdate = System.nanoTime();
+
+  public SimpleSection() {
+    this(new BlockStorage19(Version.MINECRAFT_1_17));
+  }
+
+  public SimpleBlock getBlockAt(int x, int y, int z) {
+    checkIndexes(x, y, z);
+    return blocks.get(x, y, z);
+  }
+
+  public void setBlockAt(int x, int y, int z, @Nullable SimpleBlock block) {
+    checkIndexes(x, y, z);
+    blocks.set(x, y, z, block == null ? SimpleBlock.AIR : block);
+    lastUpdate = System.nanoTime();
+  }
+
+
+  public SimpleSection getSnapshot() {
+    BlockStorage blockStorage = this.blocks.copy();
+    return new SimpleSection(blockStorage, lastUpdate);
+
+  }
+
+  private void checkIndexes(int x, int y, int z) {
+    Preconditions.checkArgument(checkIndex(x), "x should be between 0 and 15");
+    Preconditions.checkArgument(checkIndex(y), "y should be between 0 and 15");
+    Preconditions.checkArgument(checkIndex(z), "z should be between 0 and 15");
+  }
+
+  private boolean checkIndex(int i) {
+    return i >= 0 && i <= 15;
+  }
+
+}
-- 
2.29.2.windows.3

